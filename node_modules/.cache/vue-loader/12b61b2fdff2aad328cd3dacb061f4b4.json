{"remainingRequest":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/ubuntu/susecon-2024-ext-demo/node_modules/@rancher/shell/components/SideNav.vue?vue&type=style&index=0&id=54a98cce&lang=scss&scoped=true","dependencies":[{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@rancher/shell/components/SideNav.vue","mtime":1725271280091},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1725271300564},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1725271300920},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/postcss-loader/src/index.js","mtime":1725271300857},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/sass-loader/dist/cjs.js","mtime":1725271288422},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/cache-loader/dist/cjs.js","mtime":1725271299021},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1725271300920}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci5zaWRlLW5hdiB7CiAgZGlzcGxheTogZmxleDsKICBmbGV4LWRpcmVjdGlvbjogY29sdW1uOwogIC5uYXYgewogICAgZmxleDogMTsKICAgIG92ZXJmbG93LXk6IGF1dG87CiAgfQoKICBwb3NpdGlvbjogcmVsYXRpdmU7CiAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tbmF2LWJnKTsKICBib3JkZXItcmlnaHQ6IHZhcigtLW5hdi1ib3JkZXItc2l6ZSkgc29saWQgdmFyKC0tbmF2LWJvcmRlcik7CiAgb3ZlcmZsb3cteTogYXV0bzsKCiAgLy8gaDYgaXMgdXNlZCBpbiBHcm91cCBlbGVtZW50CiAgOjp2LWRlZXAgaDYgewogICAgbWFyZ2luOiAwOwogICAgbGV0dGVyLXNwYWNpbmc6IG5vcm1hbDsKICAgIGxpbmUtaGVpZ2h0OiAxNXB4OwoKICAgIEEgeyBwYWRkaW5nLWxlZnQ6IDA7IH0KICB9CgogIC50b29scyB7CiAgICBkaXNwbGF5OiBmbGV4OwogICAgbWFyZ2luOiAxMHB4OwogICAgdGV4dC1hbGlnbjogY2VudGVyOwoKICAgIEEgewogICAgICBhbGlnbi1pdGVtczogY2VudGVyOwogICAgICBib3JkZXI6IDFweCBzb2xpZCB2YXIoLS1ib3JkZXIpOwogICAgICBib3JkZXItcmFkaXVzOiA1cHg7CiAgICAgIGNvbG9yOiB2YXIoLS1ib2R5LXRleHQpOwogICAgICBkaXNwbGF5OiBmbGV4OwogICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKICAgICAgb3V0bGluZTogMDsKICAgICAgZmxleDogMTsKICAgICAgcGFkZGluZzogMTBweDsKCiAgICAgICY6aG92ZXIgewogICAgICAgIGJhY2tncm91bmQ6IHZhcigtLW5hdi1ob3Zlcik7CiAgICAgICAgdGV4dC1kZWNvcmF0aW9uOiBub25lOwogICAgICB9CgogICAgICA+IEkgewogICAgICAgIG1hcmdpbi1yaWdodDogNHB4OwogICAgICB9CiAgICB9CgogICAgJi5yb3V0ZXItbGluay1hY3RpdmU6bm90KDpob3ZlcikgewogICAgICBBIHsKICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1uYXYtYWN0aXZlKTsKICAgICAgfQogICAgfQogIH0KCiAgLnZlcnNpb24gewogICAgY3Vyc29yOiBkZWZhdWx0OwogICAgbWFyZ2luOiAwIDEwcHggMTBweCAxMHB4OwogIH0KCiAgLmZvb3RlciB7CiAgICBtYXJnaW46IDIwcHg7CgogICAgZGlzcGxheTogZmxleDsKICAgIGZsZXg6IDA7CiAgICBmbGV4LWRpcmVjdGlvbjogcm93OwogICAgPiAqIHsKICAgICAgZmxleDogMTsKICAgICAgY29sb3I6IHZhcigtLWxpbmspOwoKICAgICAgJjpsYXN0LWNoaWxkIHsKICAgICAgICB0ZXh0LWFsaWduOiByaWdodDsKICAgICAgfQoKICAgICAgJjpmaXJzdC1jaGlsZCB7CiAgICAgICAgdGV4dC1hbGlnbjogbGVmdDsKICAgICAgfQoKICAgICAgdGV4dC1hbGlnbjogY2VudGVyOwogICAgfQoKICAgIC52ZXJzaW9uIHsKICAgICAgY3Vyc29yOiBkZWZhdWx0OwogICAgICBtYXJnaW46IDBweDsKICAgIH0KCiAgICAubG9jYWxlLWNob29zZXIgewogICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICB9CiAgfQp9CgouZmxleCB7CiAgZGlzcGxheTogZmxleDsKfQoK"},{"version":3,"sources":["SideNav.vue"],"names":[],"mappings":";AAqmBA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA","file":"SideNav.vue","sourceRoot":"node_modules/@rancher/shell/components","sourcesContent":["<script>\nimport debounce from 'lodash/debounce';\nimport isEqual from 'lodash/isEqual';\nimport { mapGetters, mapState } from 'vuex';\nimport {\n  mapPref,\n  FAVORITE_TYPES\n} from '@shell/store/prefs';\nimport { getVersionInfo } from '@shell/utils/version';\nimport {\n  addObjects, replaceWith, clear, addObject, sameContents\n} from '@shell/utils/array';\nimport { sortBy } from '@shell/utils/sort';\nimport { ucFirst } from '@shell/utils/string';\n\nimport { HCI, CATALOG, UI, SCHEMA } from '@shell/config/types';\nimport { HARVESTER_NAME as HARVESTER } from '@shell/config/features';\nimport { NAME as EXPLORER } from '@shell/config/product/explorer';\nimport { TYPE_MODES } from '@shell/store/type-map';\nimport { NAME as NAVLINKS } from '@shell/config/product/navlinks';\nimport Group from '@shell/components/nav/Group';\n\nexport default {\n  name:       'SideNav',\n  components: { Group },\n  data() {\n    return {\n      groups:        [],\n      gettingGroups: false\n    };\n  },\n\n  created() {\n    // Ensure that changes to resource that change often don't resort to spamming redraw of the side nav\n    this.queueUpdate = debounce(this.getGroups, 500);\n\n    this.getGroups();\n  },\n\n  mounted() {\n    // Sync the navigation tree on fresh load\n    this.$nextTick(() => this.syncNav());\n  },\n\n  watch: {\n\n    /**\n     * Keep this simple, we're only interested in new / removed schemas\n     */\n    allSchemasIds(a, b) {\n      if ( !sameContents(a, b) ) {\n        this.queueUpdate();\n      }\n    },\n\n    allNavLinksIds(a, b) {\n      if ( !sameContents(a, b) ) {\n        this.queueUpdate();\n      }\n    },\n\n    /**\n     * Note - There's no watch on prefs, so this only catches in session changes\n     */\n    favoriteTypes(a, b) {\n      if ( !isEqual(a, b) ) {\n        this.queueUpdate();\n      }\n    },\n\n    locale(a, b) {\n      if ( !isEqual(a, b) ) {\n        this.getGroups();\n      }\n    },\n\n    productId(a, b) {\n      if ( a !== b) {\n        // Immediately update because you'll see it come in later\n        this.getGroups();\n      }\n    },\n\n    // Queue namespaceMode and namespaces\n    // Changes to namespaceMode can also change namespaces, so keep this simple and execute both in a shortened queue\n\n    namespaceMode(a, b) {\n      if ( a !== b ) {\n        this.queueUpdate();\n      }\n    },\n\n    namespaces(a, b) {\n      if ( !isEqual(a, b) ) {\n        this.queueUpdate();\n      }\n    },\n\n    clusterReady(a, b) {\n      if ( !isEqual(a, b) ) {\n        // Immediately update because you'll see it come in later\n        this.getGroups();\n      }\n    },\n\n    $route(a, b) {\n      this.$nextTick(() => this.syncNav());\n    },\n\n  },\n\n  computed: {\n    ...mapState(['managementReady', 'clusterReady']),\n    ...mapGetters(['productId', 'clusterId', 'currentProduct', 'isSingleProduct', 'namespaceMode', 'isExplorer', 'isVirtualCluster']),\n    ...mapGetters({ locale: 'i18n/selectedLocaleLabel', availableLocales: 'i18n/availableLocales' }),\n    ...mapGetters('type-map', ['activeProducts']),\n\n    favoriteTypes: mapPref(FAVORITE_TYPES),\n\n    showClusterTools() {\n      return this.isExplorer &&\n             this.$store.getters['cluster/canList'](CATALOG.CLUSTER_REPO) &&\n             this.$store.getters['cluster/canList'](CATALOG.APP);\n    },\n\n    supportLink() {\n      const product = this.currentProduct;\n\n      if (product?.supportRoute) {\n        return { ...product.supportRoute, params: { ...product.supportRoute.params, cluster: this.clusterId } };\n      }\n\n      return { name: `c-cluster-${ product?.name }-support` };\n    },\n\n    displayVersion() {\n      if (this.isSingleProduct?.getVersionInfo) {\n        return this.isSingleProduct?.getVersionInfo(this.$store);\n      }\n      const { displayVersion } = getVersionInfo(this.$store);\n\n      return displayVersion;\n    },\n\n    singleProductAbout() {\n      return this.isSingleProduct?.aboutPage;\n    },\n\n    harvesterVersion() {\n      return this.$store.getters['cluster/byId'](HCI.SETTING, 'server-version')?.value || 'unknown';\n    },\n\n    showProductFooter() {\n      if (this.isVirtualProduct) {\n        return true;\n      } else {\n        return false;\n      }\n    },\n\n    isVirtualProduct() {\n      return this.currentProduct.name === HARVESTER;\n    },\n\n    allNavLinks() {\n      if ( !this.clusterId || !this.$store.getters['cluster/schemaFor'](UI.NAV_LINK) ) {\n        return [];\n      }\n\n      return this.$store.getters['cluster/all'](UI.NAV_LINK);\n    },\n\n    allSchemasIds() {\n      const managementReady = this.managementReady;\n      const product = this.currentProduct;\n\n      if ( !managementReady || !product ) {\n        return [];\n      }\n\n      // This does take some up-front time, however avoids an even more costly getGroups call\n      return this.$store.getters[`${ product.inStore }/all`](SCHEMA).map((s) => s.id).sort();\n    },\n\n    namespaces() {\n      return this.$store.getters['activeNamespaceCache'];\n    },\n\n    allNavLinksIds() {\n      return this.allNavLinks.map((a) => a.id);\n    },\n  },\n\n  methods: {\n    /**\n     * Fetch navigation by creating groups from product schemas\n     */\n    getGroups() {\n      if ( this.gettingGroups ) {\n        return;\n      }\n      this.gettingGroups = true;\n\n      if ( !this.clusterReady ) {\n        clear(this.groups);\n        this.gettingGroups = false;\n\n        return;\n      }\n\n      const currentProduct = this.$store.getters['productId'];\n\n      // Always show cluster-level types, regardless of the namespace filter\n      const namespaceMode = 'both';\n      const out = [];\n      const loadProducts = this.isExplorer ? [EXPLORER] : [];\n\n      const productMap = this.activeProducts.reduce((acc, p) => {\n        return { ...acc, [p.name]: p };\n      }, {});\n\n      if ( this.isExplorer ) {\n        for ( const product of this.activeProducts ) {\n          if ( product.inStore === 'cluster' ) {\n            addObject(loadProducts, product.name);\n          }\n        }\n      }\n\n      // This should already have come into the list from above, but in case it hasn't...\n      addObject(loadProducts, currentProduct);\n\n      this.getProductsGroups(out, loadProducts, namespaceMode, productMap);\n\n      this.getExplorerGroups(out);\n\n      replaceWith(this.groups, ...sortBy(out, ['weight:desc', 'label']));\n\n      this.gettingGroups = false;\n    },\n\n    getProductsGroups(out, loadProducts, namespaceMode, productMap) {\n      const clusterId = this.$store.getters['clusterId'];\n      const currentType = this.$route.params.resource || '';\n\n      for ( const productId of loadProducts ) {\n        const modes = [TYPE_MODES.BASIC];\n\n        if ( productId === NAVLINKS ) {\n          // Navlinks produce their own top-level nav items so don't need to show it as a product.\n          continue;\n        }\n\n        if ( productId === EXPLORER ) {\n          modes.push(TYPE_MODES.FAVORITE);\n          modes.push(TYPE_MODES.USED);\n        }\n\n        // Get all types for all modes\n        const typesByMode = this.$store.getters['type-map/allTypes'](productId, modes);\n\n        for ( const mode of modes ) {\n          const types = typesByMode[mode] || {};\n          const more = this.$store.getters['type-map/getTree'](productId, mode, types, clusterId, namespaceMode, currentType);\n\n          if ( productId === EXPLORER || !this.isExplorer ) {\n            addObjects(out, more);\n          } else {\n            const root = more.find((x) => x.name === 'root');\n            const other = more.filter((x) => x.name !== 'root');\n\n            const group = {\n              name:     productId,\n              label:    this.$store.getters['i18n/withFallback'](`product.${ productId }`, null, ucFirst(productId)),\n              children: [...(root?.children || []), ...other],\n              weight:   productMap[productId]?.weight || 0,\n            };\n\n            addObject(out, group);\n          }\n        }\n      }\n    },\n\n    getExplorerGroups(out) {\n      if ( this.isExplorer ) {\n        const allNavLinks = this.allNavLinks;\n        const toAdd = [];\n        const haveGroup = {};\n\n        for ( const obj of allNavLinks ) {\n          if ( !obj.link ) {\n            continue;\n          }\n\n          const groupLabel = obj.spec.group;\n          const groupSlug = obj.normalizedGroup;\n\n          const entry = {\n            name:        `link-${ obj._key }`,\n            link:        obj.link,\n            target:      obj.actualTarget,\n            label:       obj.labelDisplay,\n            sideLabel:   obj.spec.sideLabel,\n            iconSrc:     obj.spec.iconSrc,\n            description: obj.spec.description,\n          };\n\n          // If there's a spec.group (groupLabel), all entries with that name go under one nav group\n          if ( groupSlug ) {\n            if ( haveGroup[groupSlug] ) {\n              continue;\n            }\n\n            haveGroup[groupSlug] = true;\n\n            toAdd.push({\n              name:     `navlink-group-${ groupSlug }`,\n              label:    groupLabel,\n              isRoot:   true,\n              // This is the item that actually shows up in the nav, since this outer group will be invisible\n              children: [\n                {\n                  name:  `navlink-child-${ groupSlug }`,\n                  label: groupLabel,\n                  route: {\n                    name:   'c-cluster-navlinks-group',\n                    params: {\n                      cluster: this.clusterId,\n                      group:   groupSlug,\n                    }\n                  },\n                }\n              ],\n              weight: -100,\n            });\n          } else {\n            toAdd.push({\n              name:     `navlink-${ entry.name }`,\n              label:    entry.label,\n              isRoot:   true,\n              // This is the item that actually shows up in the nav, since this outer group will be invisible\n              children: [entry],\n              weight:   -100,\n            });\n          }\n        }\n\n        addObjects(out, toAdd);\n      }\n    },\n\n    groupSelected(selected) {\n      this.$refs.groups.forEach((grp) => {\n        if (grp.canCollapse) {\n          grp.isExpanded = (grp.group.name === selected.name);\n        }\n      });\n    },\n\n    collapseAll() {\n      this.$refs.groups.forEach((grp) => {\n        grp.isExpanded = false;\n      });\n    },\n\n    switchLocale(locale) {\n      this.$store.dispatch('i18n/switchTo', locale);\n    },\n\n    syncNav() {\n      const refs = this.$refs.groups;\n\n      if (refs) {\n        // Only expand one group - so after the first has been expanded, no more will\n        // This prevents the 'More Resources' group being expanded in addition to the normal group\n        let canExpand = true;\n        const expanded = refs.filter((grp) => grp.isExpanded)[0];\n\n        if (expanded && expanded.hasActiveRoute()) {\n          this.$nextTick(() => expanded.syncNav());\n\n          return;\n        }\n        refs.forEach((grp) => {\n          if (!grp.group.isRoot) {\n            grp.isExpanded = false;\n            if (canExpand) {\n              const isActive = grp.hasActiveRoute();\n\n              if (isActive) {\n                grp.isExpanded = true;\n                canExpand = false;\n                this.$nextTick(() => grp.syncNav());\n              }\n            }\n          }\n        });\n      }\n    },\n  },\n};\n</script>\n\n<template>\n  <nav class=\"side-nav\">\n    <!-- Actual nav -->\n    <div class=\"nav\">\n      <template v-for=\"(g) in groups\">\n        <Group\n          ref=\"groups\"\n          :key=\"g.name\"\n          id-prefix=\"\"\n          class=\"package\"\n          :group=\"g\"\n          :can-collapse=\"!g.isRoot\"\n          :show-header=\"!g.isRoot\"\n          @selected=\"groupSelected($event)\"\n          @expand=\"groupSelected($event)\"\n        />\n      </template>\n    </div>\n    <!-- Cluster tools -->\n    <n-link\n      v-if=\"showClusterTools\"\n      tag=\"div\"\n      class=\"tools\"\n      :to=\"{name: 'c-cluster-explorer-tools', params: {cluster: clusterId}}\"\n    >\n      <a\n        class=\"tools-button\"\n        @click=\"collapseAll()\"\n      >\n        <i class=\"icon icon-gear\" />\n        <span>{{ t('nav.clusterTools') }}</span>\n      </a>\n    </n-link>\n    <!-- SideNav footer area (seems to be tied to harvester) -->\n    <div\n      v-if=\"showProductFooter\"\n      class=\"footer\"\n    >\n      <!-- support link -->\n      <nuxt-link\n        :to=\"supportLink\"\n        class=\"pull-right\"\n      >\n        {{ t('nav.support', {hasSupport: true}) }}\n      </nuxt-link>\n      <!-- version number -->\n      <span\n        v-clean-tooltip=\"{content: displayVersion, placement: 'top'}\"\n        class=\"clip version text-muted\"\n      >\n        {{ displayVersion }}\n      </span>\n\n      <!-- locale selector -->\n      <span v-if=\"isSingleProduct\">\n        <v-popover\n          popover-class=\"localeSelector\"\n          placement=\"top\"\n          trigger=\"click\"\n        >\n          <a\n            data-testid=\"locale-selector\"\n            class=\"locale-chooser\"\n          >\n            {{ locale }}\n          </a>\n\n          <template slot=\"popover\">\n            <ul\n              class=\"list-unstyled dropdown\"\n              style=\"margin: -1px;\"\n            >\n              <li\n                v-for=\"(label, name) in availableLocales\"\n                :key=\"name\"\n                class=\"hand\"\n                @click=\"switchLocale(name)\"\n              >\n                {{ label }}\n              </li>\n            </ul>\n          </template>\n        </v-popover>\n      </span>\n    </div>\n    <!-- SideNav footer alternative -->\n    <div\n      v-else\n      class=\"version text-muted flex\"\n    >\n      <nuxt-link\n        v-if=\"singleProductAbout\"\n        :to=\"singleProductAbout\"\n      >\n        {{ displayVersion }}\n      </nuxt-link>\n      <template v-else>\n        <span>{{ displayVersion }}</span>\n        <span\n          v-if=\"isVirtualCluster && isExplorer\"\n          v-tooltip=\"{content: harvesterVersion, placement: 'top'}\"\n          class=\"clip text-muted ml-5\"\n        >\n          (Harvester-{{ harvesterVersion }})\n        </span>\n      </template>\n    </div>\n  </nav>\n</template>\n\n<style lang=\"scss\" scoped>\n  .side-nav {\n    display: flex;\n    flex-direction: column;\n    .nav {\n      flex: 1;\n      overflow-y: auto;\n    }\n\n    position: relative;\n    background-color: var(--nav-bg);\n    border-right: var(--nav-border-size) solid var(--nav-border);\n    overflow-y: auto;\n\n    // h6 is used in Group element\n    ::v-deep h6 {\n      margin: 0;\n      letter-spacing: normal;\n      line-height: 15px;\n\n      A { padding-left: 0; }\n    }\n\n    .tools {\n      display: flex;\n      margin: 10px;\n      text-align: center;\n\n      A {\n        align-items: center;\n        border: 1px solid var(--border);\n        border-radius: 5px;\n        color: var(--body-text);\n        display: flex;\n        justify-content: center;\n        outline: 0;\n        flex: 1;\n        padding: 10px;\n\n        &:hover {\n          background: var(--nav-hover);\n          text-decoration: none;\n        }\n\n        > I {\n          margin-right: 4px;\n        }\n      }\n\n      &.router-link-active:not(:hover) {\n        A {\n          background-color: var(--nav-active);\n        }\n      }\n    }\n\n    .version {\n      cursor: default;\n      margin: 0 10px 10px 10px;\n    }\n\n    .footer {\n      margin: 20px;\n\n      display: flex;\n      flex: 0;\n      flex-direction: row;\n      > * {\n        flex: 1;\n        color: var(--link);\n\n        &:last-child {\n          text-align: right;\n        }\n\n        &:first-child {\n          text-align: left;\n        }\n\n        text-align: center;\n      }\n\n      .version {\n        cursor: default;\n        margin: 0px;\n      }\n\n      .locale-chooser {\n        cursor: pointer;\n      }\n    }\n  }\n\n  .flex {\n    display: flex;\n  }\n\n</style>\n"]}]}
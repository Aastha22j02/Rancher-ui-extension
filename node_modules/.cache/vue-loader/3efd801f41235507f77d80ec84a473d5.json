{"remainingRequest":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/ubuntu/susecon-2024-ext-demo/node_modules/@rancher/shell/components/Questions/index.vue?vue&type=script&lang=js","dependencies":[{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@rancher/shell/components/Questions/index.vue","mtime":1725271280091},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/cache-loader/dist/cjs.js","mtime":1725271299021},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/babel-loader/lib/index.js","mtime":1725271298942},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/cache-loader/dist/cjs.js","mtime":1725271299021},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1725271300920}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBKZXhsIGZyb20gJ2pleGwnOwppbXBvcnQgVGFiIGZyb20gJ0BzaGVsbC9jb21wb25lbnRzL1RhYmJlZC9UYWInOwppbXBvcnQgeyBnZXQsIHNldCB9IGZyb20gJ0BzaGVsbC91dGlscy9vYmplY3QnOwppbXBvcnQgeyBzb3J0QnksIGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaCc7CmltcG9ydCB7IF9FRElUIH0gZnJvbSAnQHNoZWxsL2NvbmZpZy9xdWVyeS1wYXJhbXMnOwppbXBvcnQgU3RyaW5nVHlwZSBmcm9tICcuL1N0cmluZyc7CmltcG9ydCBCb29sZWFuVHlwZSBmcm9tICcuL0Jvb2xlYW4nOwppbXBvcnQgRW51bVR5cGUgZnJvbSAnLi9FbnVtJzsKaW1wb3J0IEludFR5cGUgZnJvbSAnLi9JbnQnOwppbXBvcnQgRmxvYXRUeXBlIGZyb20gJy4vRmxvYXQnOwppbXBvcnQgQXJyYXlUeXBlIGZyb20gJy4vQXJyYXknOwppbXBvcnQgTWFwVHlwZSBmcm9tICcuL1F1ZXN0aW9uTWFwJzsKaW1wb3J0IFJlZmVyZW5jZVR5cGUgZnJvbSAnLi9SZWZlcmVuY2UnOwppbXBvcnQgQ2xvdWRDcmVkZW50aWFsVHlwZSBmcm9tICcuL0Nsb3VkQ3JlZGVudGlhbCc7CmltcG9ydCBSYWRpb1R5cGUgZnJvbSAnLi9SYWRpbyc7CmltcG9ydCBZYW1sVHlwZSBmcm9tICcuL1lhbWwnOwoKZXhwb3J0IGNvbnN0IGtub3duVHlwZXMgPSB7CiAgc3RyaW5nOiAgICAgICAgICBTdHJpbmdUeXBlLAogIGhvc3RuYW1lOiAgICAgICAgU3RyaW5nVHlwZSwKICBtdWx0aWxpbmU6ICAgICAgIFN0cmluZ1R5cGUsCiAgcGFzc3dvcmQ6ICAgICAgICBTdHJpbmdUeXBlLAogIGlwYWRkcjogICAgICAgICAgU3RyaW5nVHlwZSwKICBjaWRyOiAgICAgICAgICAgIFN0cmluZ1R5cGUsCiAgY3JvbjogICAgICAgICAgICBTdHJpbmdUeXBlLAogIGJvb2xlYW46ICAgICAgICAgQm9vbGVhblR5cGUsCiAgZW51bTogICAgICAgICAgICBFbnVtVHlwZSwKICBpbnQ6ICAgICAgICAgICAgIEludFR5cGUsCiAgZmxvYXQ6ICAgICAgICAgICBGbG9hdFR5cGUsCiAgcXVlc3Rpb25NYXA6ICAgICBNYXBUeXBlLAogIHJlZmVyZW5jZTogICAgICAgUmVmZXJlbmNlVHlwZSwKICBjb25maWdtYXA6ICAgICAgIFJlZmVyZW5jZVR5cGUsCiAgc2VjcmV0OiAgICAgICAgICBSZWZlcmVuY2VUeXBlLAogIHN0b3JhZ2VjbGFzczogICAgUmVmZXJlbmNlVHlwZSwKICBwdmM6ICAgICAgICAgICAgIFJlZmVyZW5jZVR5cGUsCiAgY2xvdWRjcmVkZW50aWFsOiBDbG91ZENyZWRlbnRpYWxUeXBlLAogIHJhZGlvOiAgICAgICAgICAgUmFkaW9UeXBlLAogIHlhbWw6ICAgICAgICAgICAgWWFtbFR5cGUsCn07CgpleHBvcnQgZnVuY3Rpb24gY29tcG9uZW50Rm9yUXVlc3Rpb24ocSkgewogIGNvbnN0IHR5cGUgPSAocS50eXBlIHx8ICcnKS50b0xvd2VyQ2FzZSgpOwoKICBpZiAoIGtub3duVHlwZXNbdHlwZV0gKSB7CiAgICByZXR1cm4gdHlwZTsKICB9IGVsc2UgaWYgKCB0eXBlLnN0YXJ0c1dpdGgoJ2FycmF5WycpICkgeyAvLyBUaGlzIG9ubHkgcmVhbGx5IHdvcmtzIGZvciBhcnJheVtzdHJpbmd8bXVsdGlsaW5lXSwgYnV0IGNsb3NlIGVub3VnaCBmb3Igbm93LgogICAgcmV0dXJuIEFycmF5VHlwZTsKICB9IGVsc2UgaWYgKCB0eXBlLnN0YXJ0c1dpdGgoJ21hcFsnKSApIHsgLy8gU2FtZSwgb25seSB3b3JrcyB3aXRoIG1hcFtzdHJpbmd8bXVsdGlsaW5lXQogICAgcmV0dXJuIE1hcFR5cGU7CiAgfSBlbHNlIGlmICggdHlwZS5zdGFydHNXaXRoKCdyZWZlcmVuY2VbJykgKSB7IC8vIFNhbWUsIG9ubHkgd29ya3Mgd2l0aCBtYXBbc3RyaW5nfG11bHRpbGluZV0KICAgIHJldHVybiBSZWZlcmVuY2VUeXBlOwogIH0KCiAgcmV0dXJuICdzdHJpbmcnOwp9CgpleHBvcnQgZnVuY3Rpb24gc2NoZW1hVG9RdWVzdGlvbnMoZmllbGRzKSB7CiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkcyk7CiAgY29uc3Qgb3V0ID0gW107CgogIGZvciAoIGNvbnN0IGsgb2Yga2V5cyApIHsKICAgIG91dC5wdXNoKHsKICAgICAgdmFyaWFibGU6IGssCiAgICAgIGxhYmVsOiAgICBrLAogICAgICAuLi5maWVsZHNba10sCiAgICB9KTsKICB9CgogIHJldHVybiBvdXQ7Cn0KCmZ1bmN0aW9uIG1pZ3JhdGUoZXhwcikgewogIGxldCBvdXQ7CgogIGlmICggZXhwci5pbmNsdWRlcygnfHwnKSApIHsKICAgIG91dCA9IGV4cHIuc3BsaXQoJ3x8JykubWFwKCh4KSA9PiBtaWdyYXRlKHgpKS5qb2luKCcgfHwgJyk7CiAgfSBlbHNlIGlmICggZXhwci5pbmNsdWRlcygnJiYnKSApIHsKICAgIG91dCA9IGV4cHIuc3BsaXQoJyYmJykubWFwKCh4KSA9PiBtaWdyYXRlKHgpKS5qb2luKCcgJiYgJyk7CiAgfSBlbHNlIHsKICAgIGNvbnN0IHBhcnRzID0gZXhwci5tYXRjaCgvXiguKikoIT89KSguKikkLyk7CgogICAgaWYgKCBwYXJ0cyApIHsKICAgICAgY29uc3Qga2V5ID0gcGFydHNbMV0udHJpbSgpOwogICAgICBjb25zdCBvcCA9IHBhcnRzWzJdLnRyaW0oKSA9PT0gJyE9JyA/ICchPScgOiAnPT0nOwogICAgICBjb25zdCB2YWwgPSBwYXJ0c1szXS50cmltKCk7CgogICAgICBpZiAoIHZhbCA9PT0gJ3RydWUnIHx8IHZhbCA9PT0gJ2ZhbHNlJyB8fCB2YWwgPT09ICdudWxsJyApIHsKICAgICAgICBvdXQgPSBgJHsga2V5IH0gJHsgb3AgfSAkeyB2YWwgfWA7CiAgICAgIH0gZWxzZSBpZiAoIHZhbCA9PT0gJycgKSB7CiAgICAgICAgLy8gRXhpc3RpbmcgY2hhcnRzIGV4cGVjdCBgZm9vPWAgd2l0aCBge2ZvbzogbnVsbH1gIHRvIGJlIHRydWUuCiAgICAgICAgaWYgKCBvcCA9PT0gJyE9JyApIHsKICAgICAgICAgIG91dCA9IGAhISR7IGtleSB9YDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgb3V0ID0gYCEkeyBrZXkgfWA7CiAgICAgICAgfQogICAgICAgIC8vIG91dCA9IGAkeyBvcCA9PT0gJyEnID8gJyEnIDogJycgfSgkeyBrZXkgfSA9PSAiIiB8fCAkeyBrZXkgfSA9PSBudWxsKWA7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgb3V0ID0gYCR7IGtleSB9ICR7IG9wIH0gIiR7IHZhbCB9ImA7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIHRyeSB7CiAgICAgICAgSmV4bC5jb21waWxlKGV4cHIpOwoKICAgICAgICBvdXQgPSBleHByOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbWlncmF0aW5nIGV4cHJlc3Npb246JywgZXhwcik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQoKICAgICAgICBvdXQgPSAndHJ1ZSc7CiAgICAgIH0KICAgIH0KICB9CgogIHJldHVybiBvdXQ7Cn0KCmV4cG9ydCBkZWZhdWx0IHsKICBjb21wb25lbnRzOiB7IFRhYiwgLi4ua25vd25UeXBlcyB9LAoKICBwcm9wczogewogICAgbW9kZTogewogICAgICB0eXBlOiAgICBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6IF9FRElULAogICAgfSwKCiAgICB2YWx1ZTogewogICAgICB0eXBlOiAgICAgT2JqZWN0LAogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgIH0sCgogICAgdGFiYmVkOiB7CiAgICAgIHR5cGU6ICAgIFtCb29sZWFuLCBTdHJpbmddLAogICAgICBkZWZhdWx0OiB0cnVlLAogICAgfSwKCiAgICAvLyBDYW4gYmUgYSBjaGFydFZlcnNpb24sIHJlc291cmNlIFNjaGVtYSwgb3IgYW4gQXJyYXkgb2YgcXVlc3Rpb24gb2JqZWN0cwogICAgc291cmNlOiB7CiAgICAgIHR5cGU6ICAgICBbT2JqZWN0LCBBcnJheV0sCiAgICAgIHJlcXVpcmVkOiB0cnVlLAogICAgfSwKCiAgICB0YXJnZXROYW1lc3BhY2U6IHsKICAgICAgdHlwZTogICAgIFN0cmluZywKICAgICAgcmVxdWlyZWQ6IHRydWUKICAgIH0sCgogICAgaWdub3JlVmFyaWFibGVzOiB7CiAgICAgIHR5cGU6ICAgIEFycmF5LAogICAgICBkZWZhdWx0OiAoKSA9PiBbXSwKICAgIH0sCgogICAgZGlzYWJsZWQ6IHsKICAgICAgdHlwZTogICAgQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UsCiAgICB9LAoKICAgIGluU3RvcmU6IHsKICAgICAgdHlwZTogICAgU3RyaW5nLAogICAgICBkZWZhdWx0OiAnY2x1c3RlcicKICAgIH0sCgogICAgZW1pdDogewogICAgICB0eXBlOiAgICBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZSwKICAgIH0KICB9LAoKICBkYXRhKCkgewogICAgcmV0dXJuIHsgdmFsdWVHZW5lcmF0aW9uOiAwIH07CiAgfSwKCiAgY29tcHV0ZWQ6IHsKICAgIGFsbFF1ZXN0aW9ucygpIHsKICAgICAgaWYgKCB0aGlzLnNvdXJjZS5xdWVzdGlvbnM/LnF1ZXN0aW9ucyApIHsKICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UucXVlc3Rpb25zLnF1ZXN0aW9uczsKICAgICAgfSBlbHNlIGlmICggdGhpcy5zb3VyY2UudHlwZSA9PT0gJ3NjaGVtYScgJiYgdGhpcy5zb3VyY2UucmVzb3VyY2VGaWVsZHMgKSB7CiAgICAgICAgcmV0dXJuIHNjaGVtYVRvUXVlc3Rpb25zKHRoaXMuc291cmNlLnJlc291cmNlRmllbGRzKTsKICAgICAgfSBlbHNlIGlmICggdHlwZW9mIHRoaXMuc291cmNlID09PSAnb2JqZWN0JyApIHsKICAgICAgICByZXR1cm4gc2NoZW1hVG9RdWVzdGlvbnModGhpcy5zb3VyY2UpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBbXTsKICAgICAgfQogICAgfSwKCiAgICBzaG93blF1ZXN0aW9ucygpIHsKICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy52YWx1ZTsKICAgICAgY29uc3Qgdm0gPSB0aGlzOwoKICAgICAgaWYgKCB0aGlzLnZhbHVlR2VuZXJhdGlvbiA8IDAgKSB7CiAgICAgICAgLy8gUG9pbnRsZXNzIGNvbmRpdGlvbiB0byBnZXQgdGhpcyB0byBkZXBlbmQgb24gZ2VuZXJhdGlvbiBhbmQgcmVjb21wdXRlCiAgICAgICAgcmV0dXJuOwogICAgICB9CgogICAgICBjb25zdCBvdXQgPSBbXTsKCiAgICAgIGZvciAoIGNvbnN0IHEgb2YgdGhpcy5hbGxRdWVzdGlvbnMgKSB7CiAgICAgICAgaWYgKCB0aGlzLmlnbm9yZVZhcmlhYmxlcy5pbmNsdWRlcyhxLnZhcmlhYmxlKSApIHsKICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgIH0KCiAgICAgICAgYWRkUXVlc3Rpb24ocSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBvdXQ7CgogICAgICBmdW5jdGlvbiBhZGRRdWVzdGlvbihxLCBkZXB0aCA9IDEsIHBhcmVudEdyb3VwKSB7CiAgICAgICAgaWYgKCAhdm0uc2hvdWxkU2hvdyhxLCB2YWx1ZXMpICkgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KCiAgICAgICAgcS5kZXB0aCA9IGRlcHRoOwogICAgICAgIHEuZ3JvdXAgPSBxLmdyb3VwIHx8IHBhcmVudEdyb3VwOwoKICAgICAgICBvdXQucHVzaChxKTsKCiAgICAgICAgaWYgKCBxLnN1YnF1ZXN0aW9ucz8ubGVuZ3RoICYmIHZtLnNob3VsZFNob3dTdWIocSwgdmFsdWVzKSApIHsKICAgICAgICAgIGZvciAoIGNvbnN0IHN1YiBvZiBxLnN1YnF1ZXN0aW9ucyApIHsKICAgICAgICAgICAgYWRkUXVlc3Rpb24oc3ViLCBkZXB0aCArIDEsIHEuZ3JvdXApOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSwKCiAgICBjaGFydE5hbWUoKSB7CiAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jaGFydD8ubmFtZTsKICAgIH0sCgogICAgZ3JvdXBzKCkgewogICAgICBjb25zdCBtYXAgPSB7fTsKICAgICAgY29uc3QgZGVmYXVsdEdyb3VwID0gJ1F1ZXN0aW9ucyc7CiAgICAgIGxldCB3ZWlnaHQgPSB0aGlzLnNob3duUXVlc3Rpb25zLmxlbmd0aDsKCiAgICAgIGZvciAoIGNvbnN0IHEgb2YgdGhpcy5zaG93blF1ZXN0aW9ucyApIHsKICAgICAgICBjb25zdCBncm91cCA9IHEuZ3JvdXAgfHwgZGVmYXVsdEdyb3VwOwoKICAgICAgICBjb25zdCBub3JtYWxpemVkID0gZ3JvdXAudHJpbSgpLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMuJHN0b3JlLmdldHRlcnNbJ2kxOG4vd2l0aEZhbGxiYWNrJ10oYGNoYXJ0cy4keyB0aGlzLmNoYXJ0TmFtZSB9Lmdyb3VwLiR7IGNhbWVsQ2FzZShncm91cCkgfWAsIG51bGwsIGdyb3VwKTsKCiAgICAgICAgaWYgKCAhbWFwW25vcm1hbGl6ZWRdICkgewogICAgICAgICAgbWFwW25vcm1hbGl6ZWRdID0gewogICAgICAgICAgICBuYW1lLAogICAgICAgICAgICBxdWVzdGlvbnM6IFtdLAogICAgICAgICAgICB3ZWlnaHQ6ICAgIHdlaWdodC0tLAogICAgICAgICAgfTsKICAgICAgICB9CgogICAgICAgIG1hcFtub3JtYWxpemVkXS5xdWVzdGlvbnMucHVzaChxKTsKICAgICAgfQoKICAgICAgY29uc3Qgb3V0ID0gT2JqZWN0LnZhbHVlcyhtYXApOwoKICAgICAgcmV0dXJuIHNvcnRCeShvdXQsICd3ZWlnaHQ6ZGVzYycpOwogICAgfSwKCiAgICBhc1RhYnMoKSB7CiAgICAgIGlmICggdGhpcy50YWJiZWQgPT09IGZhbHNlIHx8IHRoaXMudGFiYmVkID09PSAnbmV2ZXInICkgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQoKICAgICAgaWYgKCB0aGlzLnRhYmJlZCA9PT0gJ211bHRpcGxlJyApIHsKICAgICAgICByZXR1cm4gISF0aGlzLmdyb3Vwcy5sZW5ndGg7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfSwKICB9LAoKICB3YXRjaDogewogICAgdmFsdWU6IHsKICAgICAgZGVlcDogdHJ1ZSwKCiAgICAgIGhhbmRsZXIoKSB7CiAgICAgICAgdGhpcy52YWx1ZUdlbmVyYXRpb24rKzsKICAgICAgfSwKICAgIH0KICB9LAoKICBtZXRob2RzOiB7CiAgICBnZXQsCiAgICBzZXQsCiAgICBjb21wb25lbnRGb3JRdWVzdGlvbiwKCiAgICB1cGRhdGUodmFyaWFibGUsICRldmVudCkgewogICAgICBzZXQodGhpcy52YWx1ZSwgdmFyaWFibGUsICRldmVudCk7CiAgICAgIGlmICh0aGlzLmVtaXQpIHsKICAgICAgICB0aGlzLiRlbWl0KCd1cGRhdGVkJyk7CiAgICAgIH0KICAgIH0sCiAgICBldmFsRXhwcihleHByLCB2YWx1ZXMsIHF1ZXN0aW9uLCBhbGxRdWVzdGlvbnMpIHsKICAgICAgdHJ5IHsKICAgICAgICBjb25zdCBvdXQgPSBKZXhsLmV2YWxTeW5jKGV4cHIsIHZhbHVlcyk7CgogICAgICAgIC8vIGNvbnNvbGUubG9nKCdFdmFsJywgZXhwciwgJz0+ICcsIG91dCk7CgogICAgICAgIC8vIElmIHRoZSB2YXJpYWJsZSBjb250YWlucyBhIGh5cGhlbiwgY2hlY2sgaWYgaXQgZXZhbHVhdGVzIHRvIHRydWUKICAgICAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGV2YWx1YXRpb24gbG9naWMgdXNlZCBpbiB0aGUgb2xkIFVJLgogICAgICAgIC8vIFRoaXMgaGVscHMgdXNlcnMgYXZvaWQgbWFudWFsIHdvcmsgdG8gbWlncmF0ZSBmcm9tIGxlZ2FjeSBhcHBzLgogICAgICAgIGlmICghb3V0ICYmIGV4cHIuaW5jbHVkZXMoJy0nKSkgewogICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5ldmFsdWF0ZShxdWVzdGlvbiwgYWxsUXVlc3Rpb25zKTsKCiAgICAgICAgICByZXR1cm4gcmVzOwogICAgICAgIH0KCiAgICAgICAgcmV0dXJuIG91dDsKICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXZhbHVhdGluZyBleHByZXNzaW9uOicsIGV4cHIsIHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZQoKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgfSwKICAgIGV2YWx1YXRlKHF1ZXN0aW9uLCBhbGxRdWVzdGlvbnMpIHsKICAgICAgaWYgKCAhcXVlc3Rpb24uc2hvd19pZiApIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBjb25zdCBhbmQgPSBxdWVzdGlvbi5zaG93X2lmLnNwbGl0KCcmJicpOwogICAgICBjb25zdCBvciA9IHF1ZXN0aW9uLnNob3dfaWYuc3BsaXQoJ3x8Jyk7CgogICAgICBsZXQgcmVzdWx0OwoKICAgICAgaWYgKCBnZXQob3IsICdsZW5ndGgnKSA+IDEgKSB7CiAgICAgICAgcmVzdWx0ID0gb3Iuc29tZSgoc2hvd0lmKSA9PiB0aGlzLmNhbEV4cHJlc3Npb24oc2hvd0lmLCBhbGxRdWVzdGlvbnMpKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXN1bHQgPSBhbmQuZXZlcnkoKHNob3dJZikgPT4gdGhpcy5jYWxFeHByZXNzaW9uKHNob3dJZiwgYWxsUXVlc3Rpb25zKSk7CiAgICAgIH0KCiAgICAgIHJldHVybiByZXN1bHQ7CiAgICB9LAogICAgY2FsRXhwcmVzc2lvbihzaG93SWYsIGFsbFF1ZXN0aW9ucykgewogICAgICBpZiAoIHNob3dJZi5pbmNsdWRlcygnIT0nKSkgewogICAgICAgIHJldHVybiB0aGlzLmlzTm90RXF1YWwoc2hvd0lmLCBhbGxRdWVzdGlvbnMpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB0aGlzLmlzRXF1YWwoc2hvd0lmLCBhbGxRdWVzdGlvbnMpOwogICAgICB9CiAgICB9LAogICAgaXNFcXVhbChzaG93SWYsIGFsbFF1ZXN0aW9ucykgewogICAgICBzaG93SWYgPSBzaG93SWYudHJpbSgpOwogICAgICBjb25zdCB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhzaG93SWYsICc9Jyk7CgogICAgICBpZiAoIHZhcmlhYmxlcyApIHsKICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5zdHJpbmdpZnlBbnN3ZXIodGhpcy5nZXRBbnN3ZXIodmFyaWFibGVzLmxlZnQsIGFsbFF1ZXN0aW9ucykpOwogICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5zdHJpbmdpZnlBbnN3ZXIodmFyaWFibGVzLnJpZ2h0KTsKCiAgICAgICAgcmV0dXJuIGxlZnQgPT09IHJpZ2h0OwogICAgICB9CgogICAgICByZXR1cm4gZmFsc2U7CiAgICB9LAogICAgaXNOb3RFcXVhbChzaG93SWYsIGFsbFF1ZXN0aW9ucykgewogICAgICBzaG93SWYgPSBzaG93SWYudHJpbSgpOwogICAgICBjb25zdCB2YXJpYWJsZXMgPSB0aGlzLmdldFZhcmlhYmxlcyhzaG93SWYsICchPScpOwoKICAgICAgaWYgKCB2YXJpYWJsZXMgKSB7CiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMuc3RyaW5naWZ5QW5zd2VyKHRoaXMuZ2V0QW5zd2VyKHZhcmlhYmxlcy5sZWZ0LCBhbGxRdWVzdGlvbnMpKTsKICAgICAgICBjb25zdCByaWdodCA9IHRoaXMuc3RyaW5naWZ5QW5zd2VyKHZhcmlhYmxlcy5yaWdodCk7CgogICAgICAgIHJldHVybiBsZWZ0ICE9PSByaWdodDsKICAgICAgfQoKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSwKICAgIGdldFZhcmlhYmxlcyhzaG93SWYsIG9wZXJhdG9yKSB7CiAgICAgIGlmICggc2hvd0lmLmluY2x1ZGVzKG9wZXJhdG9yKSkgewogICAgICAgIGNvbnN0IGFycmF5ID0gc2hvd0lmLnNwbGl0KG9wZXJhdG9yKTsKCiAgICAgICAgaWYgKCBhcnJheS5sZW5ndGggPT09IDIgKSB7CiAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICBsZWZ0OiAgYXJyYXlbMF0sCiAgICAgICAgICAgIHJpZ2h0OiBhcnJheVsxXQogICAgICAgICAgfTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgfQogICAgICB9CgogICAgICByZXR1cm4gbnVsbDsKICAgIH0sCiAgICBnZXRBbnN3ZXIodmFyaWFibGUsIHF1ZXN0aW9ucykgewogICAgICBjb25zdCBmb3VuZCA9IHF1ZXN0aW9ucy5maW5kKChxKSA9PiBxLnZhcmlhYmxlID09PSB2YXJpYWJsZSk7CgogICAgICBpZiAoIGZvdW5kICkgewogICAgICAgIC8vIEVxdWl2YWxlbnQgdG8gZmluZGluZyBxdWVzdGlvbi5hbnN3ZXIgaW4gRW1iZXIKICAgICAgICByZXR1cm4gZ2V0KHRoaXMudmFsdWUsIGZvdW5kLnZhcmlhYmxlKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gdmFyaWFibGU7CiAgICAgIH0KICAgIH0sCiAgICBzdHJpbmdpZnlBbnN3ZXIoYW5zd2VyKSB7CiAgICAgIGlmICggYW5zd2VyID09PSB1bmRlZmluZWQgfHwgYW5zd2VyID09PSBudWxsICkgewogICAgICAgIHJldHVybiAnJzsKICAgICAgfSBlbHNlIGlmICggdHlwZW9mIGFuc3dlciA9PT0gJ3N0cmluZycgKSB7CiAgICAgICAgcmV0dXJuIGFuc3dlcjsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYCR7IGFuc3dlciB9YDsKICAgICAgfQogICAgfSwKICAgIHNob3VsZFNob3cocSwgdmFsdWVzKSB7CiAgICAgIGxldCBleHByID0gcS5pZjsKCiAgICAgIGlmICggZXhwciA9PT0gdW5kZWZpbmVkICYmIHEuc2hvd19pZiAhPT0gdW5kZWZpbmVkICkgewogICAgICAgIGV4cHIgPSBtaWdyYXRlKHEuc2hvd19pZik7CiAgICAgIH0KCiAgICAgIGlmICggZXhwciApIHsKICAgICAgICBjb25zdCBzaG93biA9ICEhdGhpcy5ldmFsRXhwcihleHByLCB2YWx1ZXMsIHEsIHRoaXMuYWxsUXVlc3Rpb25zKTsKCiAgICAgICAgcmV0dXJuIHNob3duOwogICAgICB9CgogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0sCiAgICBzaG91bGRTaG93U3ViKHEsIHZhbHVlcykgewogICAgICAvLyBTaWdoLCBib3RoIHNpbmd1bGFyIGFuZCBwbHVyYWwgYXJlIHVzZWQgaW4gdGhlIHdpbGQuLi4KICAgICAgbGV0IGV4cHIgPSAoIHEuc3VicXVlc3Rpb25zX2lmID09PSB1bmRlZmluZWQgPyBxLnN1YnF1ZXN0aW9uX2lmIDogcS5zdWJxdWVzdGlvbnNfaWYpOwogICAgICBjb25zdCBvbGQgPSAoIHEuc2hvd19zdWJxdWVzdGlvbnNfaWYgPT09IHVuZGVmaW5lZCA/IHEuc2hvd19zdWJxdWVzdGlvbl9pZiA6IHEuc2hvd19zdWJxdWVzdGlvbnNfaWYpOwoKICAgICAgaWYgKCAhZXhwciAmJiBvbGQgIT09IHVuZGVmaW5lZCApIHsKICAgICAgICBpZiAoIG9sZCA9PT0gZmFsc2UgfHwgb2xkID09PSAnZmFsc2UnICkgewogICAgICAgICAgZXhwciA9IGAhJHsgcS52YXJpYWJsZSB9YDsKICAgICAgICB9IGVsc2UgaWYgKCBvbGQgPT09IHRydWUgfHwgb2xkID09PSAndHJ1ZScgKSB7CiAgICAgICAgICBleHByID0gYCEhJHsgcS52YXJpYWJsZSB9YDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZXhwciA9IGAkeyBxLnZhcmlhYmxlIH0gPT0gIiR7IG9sZCB9ImA7CiAgICAgICAgfQogICAgICB9CgogICAgICBpZiAoIGV4cHIgKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbEV4cHIoZXhwciwgdmFsdWVzLCBxLCB0aGlzLmFsbFF1ZXN0aW9ucyk7CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfQogIH0sCn07Cg=="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"node_modules/@rancher/shell/components/Questions","sourcesContent":["<script>\nimport Jexl from 'jexl';\nimport Tab from '@shell/components/Tabbed/Tab';\nimport { get, set } from '@shell/utils/object';\nimport { sortBy, camelCase } from 'lodash';\nimport { _EDIT } from '@shell/config/query-params';\nimport StringType from './String';\nimport BooleanType from './Boolean';\nimport EnumType from './Enum';\nimport IntType from './Int';\nimport FloatType from './Float';\nimport ArrayType from './Array';\nimport MapType from './QuestionMap';\nimport ReferenceType from './Reference';\nimport CloudCredentialType from './CloudCredential';\nimport RadioType from './Radio';\nimport YamlType from './Yaml';\n\nexport const knownTypes = {\n  string:          StringType,\n  hostname:        StringType,\n  multiline:       StringType,\n  password:        StringType,\n  ipaddr:          StringType,\n  cidr:            StringType,\n  cron:            StringType,\n  boolean:         BooleanType,\n  enum:            EnumType,\n  int:             IntType,\n  float:           FloatType,\n  questionMap:     MapType,\n  reference:       ReferenceType,\n  configmap:       ReferenceType,\n  secret:          ReferenceType,\n  storageclass:    ReferenceType,\n  pvc:             ReferenceType,\n  cloudcredential: CloudCredentialType,\n  radio:           RadioType,\n  yaml:            YamlType,\n};\n\nexport function componentForQuestion(q) {\n  const type = (q.type || '').toLowerCase();\n\n  if ( knownTypes[type] ) {\n    return type;\n  } else if ( type.startsWith('array[') ) { // This only really works for array[string|multiline], but close enough for now.\n    return ArrayType;\n  } else if ( type.startsWith('map[') ) { // Same, only works with map[string|multiline]\n    return MapType;\n  } else if ( type.startsWith('reference[') ) { // Same, only works with map[string|multiline]\n    return ReferenceType;\n  }\n\n  return 'string';\n}\n\nexport function schemaToQuestions(fields) {\n  const keys = Object.keys(fields);\n  const out = [];\n\n  for ( const k of keys ) {\n    out.push({\n      variable: k,\n      label:    k,\n      ...fields[k],\n    });\n  }\n\n  return out;\n}\n\nfunction migrate(expr) {\n  let out;\n\n  if ( expr.includes('||') ) {\n    out = expr.split('||').map((x) => migrate(x)).join(' || ');\n  } else if ( expr.includes('&&') ) {\n    out = expr.split('&&').map((x) => migrate(x)).join(' && ');\n  } else {\n    const parts = expr.match(/^(.*)(!?=)(.*)$/);\n\n    if ( parts ) {\n      const key = parts[1].trim();\n      const op = parts[2].trim() === '!=' ? '!=' : '==';\n      const val = parts[3].trim();\n\n      if ( val === 'true' || val === 'false' || val === 'null' ) {\n        out = `${ key } ${ op } ${ val }`;\n      } else if ( val === '' ) {\n        // Existing charts expect `foo=` with `{foo: null}` to be true.\n        if ( op === '!=' ) {\n          out = `!!${ key }`;\n        } else {\n          out = `!${ key }`;\n        }\n        // out = `${ op === '!' ? '!' : '' }(${ key } == \"\" || ${ key } == null)`;\n      } else {\n        out = `${ key } ${ op } \"${ val }\"`;\n      }\n    } else {\n      try {\n        Jexl.compile(expr);\n\n        out = expr;\n      } catch (e) {\n        console.error('Error migrating expression:', expr); // eslint-disable-line no-console\n\n        out = 'true';\n      }\n    }\n  }\n\n  return out;\n}\n\nexport default {\n  components: { Tab, ...knownTypes },\n\n  props: {\n    mode: {\n      type:    String,\n      default: _EDIT,\n    },\n\n    value: {\n      type:     Object,\n      required: true,\n    },\n\n    tabbed: {\n      type:    [Boolean, String],\n      default: true,\n    },\n\n    // Can be a chartVersion, resource Schema, or an Array of question objects\n    source: {\n      type:     [Object, Array],\n      required: true,\n    },\n\n    targetNamespace: {\n      type:     String,\n      required: true\n    },\n\n    ignoreVariables: {\n      type:    Array,\n      default: () => [],\n    },\n\n    disabled: {\n      type:    Boolean,\n      default: false,\n    },\n\n    inStore: {\n      type:    String,\n      default: 'cluster'\n    },\n\n    emit: {\n      type:    Boolean,\n      default: false,\n    }\n  },\n\n  data() {\n    return { valueGeneration: 0 };\n  },\n\n  computed: {\n    allQuestions() {\n      if ( this.source.questions?.questions ) {\n        return this.source.questions.questions;\n      } else if ( this.source.type === 'schema' && this.source.resourceFields ) {\n        return schemaToQuestions(this.source.resourceFields);\n      } else if ( typeof this.source === 'object' ) {\n        return schemaToQuestions(this.source);\n      } else {\n        return [];\n      }\n    },\n\n    shownQuestions() {\n      const values = this.value;\n      const vm = this;\n\n      if ( this.valueGeneration < 0 ) {\n        // Pointless condition to get this to depend on generation and recompute\n        return;\n      }\n\n      const out = [];\n\n      for ( const q of this.allQuestions ) {\n        if ( this.ignoreVariables.includes(q.variable) ) {\n          continue;\n        }\n\n        addQuestion(q);\n      }\n\n      return out;\n\n      function addQuestion(q, depth = 1, parentGroup) {\n        if ( !vm.shouldShow(q, values) ) {\n          return;\n        }\n\n        q.depth = depth;\n        q.group = q.group || parentGroup;\n\n        out.push(q);\n\n        if ( q.subquestions?.length && vm.shouldShowSub(q, values) ) {\n          for ( const sub of q.subquestions ) {\n            addQuestion(sub, depth + 1, q.group);\n          }\n        }\n      }\n    },\n\n    chartName() {\n      return this.source.chart?.name;\n    },\n\n    groups() {\n      const map = {};\n      const defaultGroup = 'Questions';\n      let weight = this.shownQuestions.length;\n\n      for ( const q of this.shownQuestions ) {\n        const group = q.group || defaultGroup;\n\n        const normalized = group.trim().toLowerCase();\n        const name = this.$store.getters['i18n/withFallback'](`charts.${ this.chartName }.group.${ camelCase(group) }`, null, group);\n\n        if ( !map[normalized] ) {\n          map[normalized] = {\n            name,\n            questions: [],\n            weight:    weight--,\n          };\n        }\n\n        map[normalized].questions.push(q);\n      }\n\n      const out = Object.values(map);\n\n      return sortBy(out, 'weight:desc');\n    },\n\n    asTabs() {\n      if ( this.tabbed === false || this.tabbed === 'never' ) {\n        return false;\n      }\n\n      if ( this.tabbed === 'multiple' ) {\n        return !!this.groups.length;\n      }\n\n      return true;\n    },\n  },\n\n  watch: {\n    value: {\n      deep: true,\n\n      handler() {\n        this.valueGeneration++;\n      },\n    }\n  },\n\n  methods: {\n    get,\n    set,\n    componentForQuestion,\n\n    update(variable, $event) {\n      set(this.value, variable, $event);\n      if (this.emit) {\n        this.$emit('updated');\n      }\n    },\n    evalExpr(expr, values, question, allQuestions) {\n      try {\n        const out = Jexl.evalSync(expr, values);\n\n        // console.log('Eval', expr, '=> ', out);\n\n        // If the variable contains a hyphen, check if it evaluates to true\n        // according to the evaluation logic used in the old UI.\n        // This helps users avoid manual work to migrate from legacy apps.\n        if (!out && expr.includes('-')) {\n          const res = this.evaluate(question, allQuestions);\n\n          return res;\n        }\n\n        return out;\n      } catch (err) {\n        console.error('Error evaluating expression:', expr, values); // eslint-disable-line no-console\n\n        return true;\n      }\n    },\n    evaluate(question, allQuestions) {\n      if ( !question.show_if ) {\n        return true;\n      }\n      const and = question.show_if.split('&&');\n      const or = question.show_if.split('||');\n\n      let result;\n\n      if ( get(or, 'length') > 1 ) {\n        result = or.some((showIf) => this.calExpression(showIf, allQuestions));\n      } else {\n        result = and.every((showIf) => this.calExpression(showIf, allQuestions));\n      }\n\n      return result;\n    },\n    calExpression(showIf, allQuestions) {\n      if ( showIf.includes('!=')) {\n        return this.isNotEqual(showIf, allQuestions);\n      } else {\n        return this.isEqual(showIf, allQuestions);\n      }\n    },\n    isEqual(showIf, allQuestions) {\n      showIf = showIf.trim();\n      const variables = this.getVariables(showIf, '=');\n\n      if ( variables ) {\n        const left = this.stringifyAnswer(this.getAnswer(variables.left, allQuestions));\n        const right = this.stringifyAnswer(variables.right);\n\n        return left === right;\n      }\n\n      return false;\n    },\n    isNotEqual(showIf, allQuestions) {\n      showIf = showIf.trim();\n      const variables = this.getVariables(showIf, '!=');\n\n      if ( variables ) {\n        const left = this.stringifyAnswer(this.getAnswer(variables.left, allQuestions));\n        const right = this.stringifyAnswer(variables.right);\n\n        return left !== right;\n      }\n\n      return false;\n    },\n    getVariables(showIf, operator) {\n      if ( showIf.includes(operator)) {\n        const array = showIf.split(operator);\n\n        if ( array.length === 2 ) {\n          return {\n            left:  array[0],\n            right: array[1]\n          };\n        } else {\n          return null;\n        }\n      }\n\n      return null;\n    },\n    getAnswer(variable, questions) {\n      const found = questions.find((q) => q.variable === variable);\n\n      if ( found ) {\n        // Equivalent to finding question.answer in Ember\n        return get(this.value, found.variable);\n      } else {\n        return variable;\n      }\n    },\n    stringifyAnswer(answer) {\n      if ( answer === undefined || answer === null ) {\n        return '';\n      } else if ( typeof answer === 'string' ) {\n        return answer;\n      } else {\n        return `${ answer }`;\n      }\n    },\n    shouldShow(q, values) {\n      let expr = q.if;\n\n      if ( expr === undefined && q.show_if !== undefined ) {\n        expr = migrate(q.show_if);\n      }\n\n      if ( expr ) {\n        const shown = !!this.evalExpr(expr, values, q, this.allQuestions);\n\n        return shown;\n      }\n\n      return true;\n    },\n    shouldShowSub(q, values) {\n      // Sigh, both singular and plural are used in the wild...\n      let expr = ( q.subquestions_if === undefined ? q.subquestion_if : q.subquestions_if);\n      const old = ( q.show_subquestions_if === undefined ? q.show_subquestion_if : q.show_subquestions_if);\n\n      if ( !expr && old !== undefined ) {\n        if ( old === false || old === 'false' ) {\n          expr = `!${ q.variable }`;\n        } else if ( old === true || old === 'true' ) {\n          expr = `!!${ q.variable }`;\n        } else {\n          expr = `${ q.variable } == \"${ old }\"`;\n        }\n      }\n\n      if ( expr ) {\n        return this.evalExpr(expr, values, q, this.allQuestions);\n      }\n\n      return true;\n    }\n  },\n};\n</script>\n\n<template>\n  <form v-if=\"asTabs\">\n    <Tab\n      v-for=\"g in groups\"\n      :key=\"g.name\"\n      :name=\"g.name\"\n      :label=\"g.name\"\n      :weight=\"g.weight\"\n    >\n      <div\n        v-for=\"q in g.questions\"\n        :key=\"q.variable\"\n        class=\"row question\"\n      >\n        <div class=\"col span-12\">\n          <component\n            :is=\"componentForQuestion(q)\"\n            :in-store=\"inStore\"\n            :question=\"q\"\n            :target-namespace=\"targetNamespace\"\n            :value=\"get(value, q.variable)\"\n            :disabled=\"disabled\"\n            :chart-name=\"chartName\"\n            @input=\"update(q.variable, $event)\"\n          />\n        </div>\n      </div>\n    </Tab>\n  </form>\n  <form v-else>\n    <div\n      v-for=\"g in groups\"\n      :key=\"g.name\"\n    >\n      <h3 v-if=\"groups.length > 1\">\n        {{ g.label }}\n      </h3>\n      <div\n        v-for=\"q in g.questions\"\n        :key=\"q.variable\"\n        class=\"row question\"\n      >\n        <div class=\"col span-12\">\n          <component\n            :is=\"componentForQuestion(q)\"\n            :in-store=\"inStore\"\n            :question=\"q\"\n            :target-namespace=\"targetNamespace\"\n            :mode=\"mode\"\n            :value=\"get(value, q.variable)\"\n            :disabled=\"disabled\"\n            :chart-name=\"chartName\"\n            @input=\"update(q.variable, $event)\"\n          />\n        </div>\n      </div>\n    </div>\n  </form>\n</template>\n\n<style lang=\"scss\" scoped>\n  .question {\n    margin-top: 10px;\n\n    &:first-child {\n      margin-top: 0;\n    }\n  }\n</style>\n"]}]}
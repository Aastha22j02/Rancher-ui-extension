{"remainingRequest":"/home/ubuntu/suseconf/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/ubuntu/suseconf/node_modules/@rancher/shell/components/Questions/index.vue?vue&type=script&lang=js","dependencies":[{"path":"/home/ubuntu/suseconf/node_modules/@rancher/shell/components/Questions/index.vue","mtime":1725338146566},{"path":"/home/ubuntu/suseconf/node_modules/cache-loader/dist/cjs.js","mtime":1725271299021},{"path":"/home/ubuntu/suseconf/node_modules/babel-loader/lib/index.js","mtime":1725271298942},{"path":"/home/ubuntu/suseconf/node_modules/cache-loader/dist/cjs.js","mtime":1725271299021},{"path":"/home/ubuntu/suseconf/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1725271300920}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CmltcG9ydCBKZXhsIGZyb20gJ2pleGwnOwppbXBvcnQgVGFiIGZyb20gJ0BzaGVsbC9jb21wb25lbnRzL1RhYmJlZC9UYWInOwppbXBvcnQgeyBnZXQsIHNldCB9IGZyb20gJ0BzaGVsbC91dGlscy9vYmplY3QnOwppbXBvcnQgeyBzb3J0QnksIGNhbWVsQ2FzZSB9IGZyb20gJ2xvZGFzaCc7CmltcG9ydCB7IF9FRElUIH0gZnJvbSAnQHNoZWxsL2NvbmZpZy9xdWVyeS1wYXJhbXMnOwppbXBvcnQgU3RyaW5nVHlwZSBmcm9tICcuL1N0cmluZyc7CmltcG9ydCBCb29sZWFuVHlwZSBmcm9tICcuL0Jvb2xlYW4nOwppbXBvcnQgRW51bVR5cGUgZnJvbSAnLi9FbnVtJzsKaW1wb3J0IEludFR5cGUgZnJvbSAnLi9JbnQnOwppbXBvcnQgRmxvYXRUeXBlIGZyb20gJy4vRmxvYXQnOwppbXBvcnQgQXJyYXlUeXBlIGZyb20gJy4vQXJyYXknOwppbXBvcnQgTWFwVHlwZSBmcm9tICcuL1F1ZXN0aW9uTWFwJzsKaW1wb3J0IFJlZmVyZW5jZVR5cGUgZnJvbSAnLi9SZWZlcmVuY2UnOwppbXBvcnQgQ2xvdWRDcmVkZW50aWFsVHlwZSBmcm9tICcuL0Nsb3VkQ3JlZGVudGlhbCc7CmltcG9ydCBSYWRpb1R5cGUgZnJvbSAnLi9SYWRpbyc7CmltcG9ydCBZYW1sVHlwZSBmcm9tICcuL1lhbWwnOwppbXBvcnQgTG9hZGluZyBmcm9tICdAc2hlbGwvY29tcG9uZW50cy9Mb2FkaW5nJzsKCmV4cG9ydCBjb25zdCBrbm93blR5cGVzID0gewogIHN0cmluZzogICAgICAgICAgU3RyaW5nVHlwZSwKICBob3N0bmFtZTogICAgICAgIFN0cmluZ1R5cGUsCiAgbXVsdGlsaW5lOiAgICAgICBTdHJpbmdUeXBlLAogIHBhc3N3b3JkOiAgICAgICAgU3RyaW5nVHlwZSwKICBpcGFkZHI6ICAgICAgICAgIFN0cmluZ1R5cGUsCiAgY2lkcjogICAgICAgICAgICBTdHJpbmdUeXBlLAogIGNyb246ICAgICAgICAgICAgU3RyaW5nVHlwZSwKICBib29sZWFuOiAgICAgICAgIEJvb2xlYW5UeXBlLAogIGVudW06ICAgICAgICAgICAgRW51bVR5cGUsCiAgaW50OiAgICAgICAgICAgICBJbnRUeXBlLAogIGZsb2F0OiAgICAgICAgICAgRmxvYXRUeXBlLAogIHF1ZXN0aW9uTWFwOiAgICAgTWFwVHlwZSwKICByZWZlcmVuY2U6ICAgICAgIFJlZmVyZW5jZVR5cGUsCiAgY29uZmlnbWFwOiAgICAgICBSZWZlcmVuY2VUeXBlLAogIHNlY3JldDogICAgICAgICAgUmVmZXJlbmNlVHlwZSwKICBzdG9yYWdlY2xhc3M6ICAgIFJlZmVyZW5jZVR5cGUsCiAgcHZjOiAgICAgICAgICAgICBSZWZlcmVuY2VUeXBlLAogIGNsb3VkY3JlZGVudGlhbDogQ2xvdWRDcmVkZW50aWFsVHlwZSwKICByYWRpbzogICAgICAgICAgIFJhZGlvVHlwZSwKICB5YW1sOiAgICAgICAgICAgIFlhbWxUeXBlLAp9OwoKZXhwb3J0IGZ1bmN0aW9uIGNvbXBvbmVudEZvclF1ZXN0aW9uKHEpIHsKICBjb25zdCB0eXBlID0gKHEudHlwZSB8fCAnJykudG9Mb3dlckNhc2UoKTsKCiAgaWYgKCBrbm93blR5cGVzW3R5cGVdICkgewogICAgcmV0dXJuIHR5cGU7CiAgfSBlbHNlIGlmICggdHlwZS5zdGFydHNXaXRoKCdhcnJheVsnKSApIHsgLy8gVGhpcyBvbmx5IHJlYWxseSB3b3JrcyBmb3IgYXJyYXlbc3RyaW5nfG11bHRpbGluZV0sIGJ1dCBjbG9zZSBlbm91Z2ggZm9yIG5vdy4KICAgIHJldHVybiBBcnJheVR5cGU7CiAgfSBlbHNlIGlmICggdHlwZS5zdGFydHNXaXRoKCdtYXBbJykgKSB7IC8vIFNhbWUsIG9ubHkgd29ya3Mgd2l0aCBtYXBbc3RyaW5nfG11bHRpbGluZV0KICAgIHJldHVybiBNYXBUeXBlOwogIH0gZWxzZSBpZiAoIHR5cGUuc3RhcnRzV2l0aCgncmVmZXJlbmNlWycpICkgeyAvLyBTYW1lLCBvbmx5IHdvcmtzIHdpdGggbWFwW3N0cmluZ3xtdWx0aWxpbmVdCiAgICByZXR1cm4gUmVmZXJlbmNlVHlwZTsKICB9CgogIHJldHVybiAnc3RyaW5nJzsKfQoKZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYVRvUXVlc3Rpb25zKGZpZWxkcykgewogIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmaWVsZHMpOwogIGNvbnN0IG91dCA9IFtdOwoKICBmb3IgKCBjb25zdCBrIG9mIGtleXMgKSB7CiAgICBvdXQucHVzaCh7CiAgICAgIHZhcmlhYmxlOiBrLAogICAgICBsYWJlbDogICAgaywKICAgICAgLi4uZmllbGRzW2tdLAogICAgfSk7CiAgfQoKICByZXR1cm4gb3V0Owp9CgpmdW5jdGlvbiBtaWdyYXRlKGV4cHIpIHsKICBsZXQgb3V0OwoKICBpZiAoIGV4cHIuaW5jbHVkZXMoJ3x8JykgKSB7CiAgICBvdXQgPSBleHByLnNwbGl0KCd8fCcpLm1hcCgoeCkgPT4gbWlncmF0ZSh4KSkuam9pbignIHx8ICcpOwogIH0gZWxzZSBpZiAoIGV4cHIuaW5jbHVkZXMoJyYmJykgKSB7CiAgICBvdXQgPSBleHByLnNwbGl0KCcmJicpLm1hcCgoeCkgPT4gbWlncmF0ZSh4KSkuam9pbignICYmICcpOwogIH0gZWxzZSB7CiAgICBjb25zdCBwYXJ0cyA9IGV4cHIubWF0Y2goL14oLiopKCE/PSkoLiopJC8pOwoKICAgIGlmICggcGFydHMgKSB7CiAgICAgIGNvbnN0IGtleSA9IHBhcnRzWzFdLnRyaW0oKTsKICAgICAgY29uc3Qgb3AgPSBwYXJ0c1syXS50cmltKCkgPT09ICchPScgPyAnIT0nIDogJz09JzsKICAgICAgY29uc3QgdmFsID0gcGFydHNbM10udHJpbSgpOwoKICAgICAgaWYgKCB2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICdmYWxzZScgfHwgdmFsID09PSAnbnVsbCcgKSB7CiAgICAgICAgb3V0ID0gYCR7IGtleSB9ICR7IG9wIH0gJHsgdmFsIH1gOwogICAgICB9IGVsc2UgaWYgKCB2YWwgPT09ICcnICkgewogICAgICAgIC8vIEV4aXN0aW5nIGNoYXJ0cyBleHBlY3QgYGZvbz1gIHdpdGggYHtmb286IG51bGx9YCB0byBiZSB0cnVlLgogICAgICAgIGlmICggb3AgPT09ICchPScgKSB7CiAgICAgICAgICBvdXQgPSBgISEkeyBrZXkgfWA7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG91dCA9IGAhJHsga2V5IH1gOwogICAgICAgIH0KICAgICAgICAvLyBvdXQgPSBgJHsgb3AgPT09ICchJyA/ICchJyA6ICcnIH0oJHsga2V5IH0gPT0gIiIgfHwgJHsga2V5IH0gPT0gbnVsbClgOwogICAgICB9IGVsc2UgewogICAgICAgIG91dCA9IGAkeyBrZXkgfSAkeyBvcCB9ICIkeyB2YWwgfSJgOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICB0cnkgewogICAgICAgIEpleGwuY29tcGlsZShleHByKTsKCiAgICAgICAgb3V0ID0gZXhwcjsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG1pZ3JhdGluZyBleHByZXNzaW9uOicsIGV4cHIpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGUKCiAgICAgICAgb3V0ID0gJ3RydWUnOwogICAgICB9CiAgICB9CiAgfQoKICByZXR1cm4gb3V0Owp9CgpleHBvcnQgZGVmYXVsdCB7CiAgY29tcG9uZW50czogewogICAgLi4ua25vd25UeXBlcywKICAgIFRhYiwKICAgIExvYWRpbmcsCiAgfSwKCiAgcHJvcHM6IHsKICAgIG1vZGU6IHsKICAgICAgdHlwZTogICAgU3RyaW5nLAogICAgICBkZWZhdWx0OiBfRURJVCwKICAgIH0sCgogICAgdmFsdWU6IHsKICAgICAgdHlwZTogICAgIE9iamVjdCwKICAgICAgcmVxdWlyZWQ6IHRydWUsCiAgICB9LAoKICAgIHRhYmJlZDogewogICAgICB0eXBlOiAgICBbQm9vbGVhbiwgU3RyaW5nXSwKICAgICAgZGVmYXVsdDogdHJ1ZSwKICAgIH0sCgogICAgLy8gQ2FuIGJlIGEgY2hhcnRWZXJzaW9uLCByZXNvdXJjZSBTY2hlbWEsIG9yIGFuIEFycmF5IG9mIHF1ZXN0aW9uIG9iamVjdHMKICAgIHNvdXJjZTogewogICAgICB0eXBlOiAgICAgW09iamVjdCwgQXJyYXldLAogICAgICByZXF1aXJlZDogdHJ1ZSwKICAgIH0sCgogICAgdGFyZ2V0TmFtZXNwYWNlOiB7CiAgICAgIHR5cGU6ICAgICBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICB9LAoKICAgIGlnbm9yZVZhcmlhYmxlczogewogICAgICB0eXBlOiAgICBBcnJheSwKICAgICAgZGVmYXVsdDogKCkgPT4gW10sCiAgICB9LAoKICAgIGRpc2FibGVkOiB7CiAgICAgIHR5cGU6ICAgIEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlLAogICAgfSwKCiAgICBpblN0b3JlOiB7CiAgICAgIHR5cGU6ICAgIFN0cmluZywKICAgICAgZGVmYXVsdDogJ2NsdXN0ZXInCiAgICB9LAoKICAgIGVtaXQ6IHsKICAgICAgdHlwZTogICAgQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UsCiAgICB9CiAgfSwKCiAgYXN5bmMgZmV0Y2goKSB7CiAgICAvLyBJZiB0aGlzIHNvdXJjZSBpcyBhIHNjaGVtYSwgZW5zdXJlIHRoZSBzY2hlbWEncyBgcmVzb3VyY2VGaWVsZHNgIGlzIHBvcHVsYXRlZAogICAgaWYgKHRoaXMuc291cmNlLnR5cGUgPT09ICdzY2hlbWEnICYmIHRoaXMuc291cmNlLnJlcXVpcmVzUmVzb3VyY2VGaWVsZHMpIHsKICAgICAgYXdhaXQgdGhpcy5zb3VyY2UuZmV0Y2hSZXNvdXJjZUZpZWxkcygpOwogICAgfQogIH0sCgogIGRhdGEoKSB7CiAgICByZXR1cm4geyB2YWx1ZUdlbmVyYXRpb246IDAgfTsKICB9LAoKICBjb21wdXRlZDogewogICAgYWxsUXVlc3Rpb25zKCkgewogICAgICBpZiAoIHRoaXMuc291cmNlLnF1ZXN0aW9ucz8ucXVlc3Rpb25zICkgewogICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5xdWVzdGlvbnMucXVlc3Rpb25zOwogICAgICB9IGVsc2UgaWYgKCB0aGlzLnNvdXJjZS50eXBlID09PSAnc2NoZW1hJyAmJiB0aGlzLnNvdXJjZS5yZXNvdXJjZUZpZWxkcyApIHsKICAgICAgICByZXR1cm4gc2NoZW1hVG9RdWVzdGlvbnModGhpcy5zb3VyY2UucmVzb3VyY2VGaWVsZHMpOwogICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgdGhpcy5zb3VyY2UgPT09ICdvYmplY3QnICkgewogICAgICAgIHJldHVybiBzY2hlbWFUb1F1ZXN0aW9ucyh0aGlzLnNvdXJjZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIFtdOwogICAgICB9CiAgICB9LAoKICAgIHNob3duUXVlc3Rpb25zKCkgewogICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlOwogICAgICBjb25zdCB2bSA9IHRoaXM7CgogICAgICBpZiAoIHRoaXMudmFsdWVHZW5lcmF0aW9uIDwgMCApIHsKICAgICAgICAvLyBQb2ludGxlc3MgY29uZGl0aW9uIHRvIGdldCB0aGlzIHRvIGRlcGVuZCBvbiBnZW5lcmF0aW9uIGFuZCByZWNvbXB1dGUKICAgICAgICByZXR1cm47CiAgICAgIH0KCiAgICAgIGNvbnN0IG91dCA9IFtdOwoKICAgICAgZm9yICggY29uc3QgcSBvZiB0aGlzLmFsbFF1ZXN0aW9ucyApIHsKICAgICAgICBpZiAoIHRoaXMuaWdub3JlVmFyaWFibGVzLmluY2x1ZGVzKHEudmFyaWFibGUpICkgewogICAgICAgICAgY29udGludWU7CiAgICAgICAgfQoKICAgICAgICBhZGRRdWVzdGlvbihxKTsKICAgICAgfQoKICAgICAgcmV0dXJuIG91dDsKCiAgICAgIGZ1bmN0aW9uIGFkZFF1ZXN0aW9uKHEsIGRlcHRoID0gMSwgcGFyZW50R3JvdXApIHsKICAgICAgICBpZiAoICF2bS5zaG91bGRTaG93KHEsIHZhbHVlcykgKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQoKICAgICAgICBxLmRlcHRoID0gZGVwdGg7CiAgICAgICAgcS5ncm91cCA9IHEuZ3JvdXAgfHwgcGFyZW50R3JvdXA7CgogICAgICAgIG91dC5wdXNoKHEpOwoKICAgICAgICBpZiAoIHEuc3VicXVlc3Rpb25zPy5sZW5ndGggJiYgdm0uc2hvdWxkU2hvd1N1YihxLCB2YWx1ZXMpICkgewogICAgICAgICAgZm9yICggY29uc3Qgc3ViIG9mIHEuc3VicXVlc3Rpb25zICkgewogICAgICAgICAgICBhZGRRdWVzdGlvbihzdWIsIGRlcHRoICsgMSwgcS5ncm91cCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9LAoKICAgIGNoYXJ0TmFtZSgpIHsKICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNoYXJ0Py5uYW1lOwogICAgfSwKCiAgICBncm91cHMoKSB7CiAgICAgIGNvbnN0IG1hcCA9IHt9OwogICAgICBjb25zdCBkZWZhdWx0R3JvdXAgPSAnUXVlc3Rpb25zJzsKICAgICAgbGV0IHdlaWdodCA9IHRoaXMuc2hvd25RdWVzdGlvbnMubGVuZ3RoOwoKICAgICAgZm9yICggY29uc3QgcSBvZiB0aGlzLnNob3duUXVlc3Rpb25zICkgewogICAgICAgIGNvbnN0IGdyb3VwID0gcS5ncm91cCB8fCBkZWZhdWx0R3JvdXA7CgogICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBncm91cC50cmltKCkudG9Mb3dlckNhc2UoKTsKICAgICAgICBjb25zdCBuYW1lID0gdGhpcy4kc3RvcmUuZ2V0dGVyc1snaTE4bi93aXRoRmFsbGJhY2snXShgY2hhcnRzLiR7IHRoaXMuY2hhcnROYW1lIH0uZ3JvdXAuJHsgY2FtZWxDYXNlKGdyb3VwKSB9YCwgbnVsbCwgZ3JvdXApOwoKICAgICAgICBpZiAoICFtYXBbbm9ybWFsaXplZF0gKSB7CiAgICAgICAgICBtYXBbbm9ybWFsaXplZF0gPSB7CiAgICAgICAgICAgIG5hbWUsCiAgICAgICAgICAgIHF1ZXN0aW9uczogW10sCiAgICAgICAgICAgIHdlaWdodDogICAgd2VpZ2h0LS0sCiAgICAgICAgICB9OwogICAgICAgIH0KCiAgICAgICAgbWFwW25vcm1hbGl6ZWRdLnF1ZXN0aW9ucy5wdXNoKHEpOwogICAgICB9CgogICAgICBjb25zdCBvdXQgPSBPYmplY3QudmFsdWVzKG1hcCk7CgogICAgICByZXR1cm4gc29ydEJ5KG91dCwgJ3dlaWdodDpkZXNjJyk7CiAgICB9LAoKICAgIGFzVGFicygpIHsKICAgICAgaWYgKCB0aGlzLnRhYmJlZCA9PT0gZmFsc2UgfHwgdGhpcy50YWJiZWQgPT09ICduZXZlcicgKSB7CiAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICB9CgogICAgICBpZiAoIHRoaXMudGFiYmVkID09PSAnbXVsdGlwbGUnICkgewogICAgICAgIHJldHVybiAhIXRoaXMuZ3JvdXBzLmxlbmd0aDsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9LAogIH0sCgogIHdhdGNoOiB7CiAgICB2YWx1ZTogewogICAgICBkZWVwOiB0cnVlLAoKICAgICAgaGFuZGxlcigpIHsKICAgICAgICB0aGlzLnZhbHVlR2VuZXJhdGlvbisrOwogICAgICB9LAogICAgfQogIH0sCgogIG1ldGhvZHM6IHsKICAgIGdldCwKICAgIHNldCwKICAgIGNvbXBvbmVudEZvclF1ZXN0aW9uLAoKICAgIHVwZGF0ZSh2YXJpYWJsZSwgJGV2ZW50KSB7CiAgICAgIHNldCh0aGlzLnZhbHVlLCB2YXJpYWJsZSwgJGV2ZW50KTsKICAgICAgaWYgKHRoaXMuZW1pdCkgewogICAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZWQnKTsKICAgICAgfQogICAgfSwKICAgIGV2YWxFeHByKGV4cHIsIHZhbHVlcywgcXVlc3Rpb24sIGFsbFF1ZXN0aW9ucykgewogICAgICB0cnkgewogICAgICAgIGNvbnN0IG91dCA9IEpleGwuZXZhbFN5bmMoZXhwciwgdmFsdWVzKTsKCiAgICAgICAgLy8gY29uc29sZS5sb2coJ0V2YWwnLCBleHByLCAnPT4gJywgb3V0KTsKCiAgICAgICAgLy8gSWYgdGhlIHZhcmlhYmxlIGNvbnRhaW5zIGEgaHlwaGVuLCBjaGVjayBpZiBpdCBldmFsdWF0ZXMgdG8gdHJ1ZQogICAgICAgIC8vIGFjY29yZGluZyB0byB0aGUgZXZhbHVhdGlvbiBsb2dpYyB1c2VkIGluIHRoZSBvbGQgVUkuCiAgICAgICAgLy8gVGhpcyBoZWxwcyB1c2VycyBhdm9pZCBtYW51YWwgd29yayB0byBtaWdyYXRlIGZyb20gbGVnYWN5IGFwcHMuCiAgICAgICAgaWYgKCFvdXQgJiYgZXhwci5pbmNsdWRlcygnLScpKSB7CiAgICAgICAgICBjb25zdCByZXMgPSB0aGlzLmV2YWx1YXRlKHF1ZXN0aW9uLCBhbGxRdWVzdGlvbnMpOwoKICAgICAgICAgIHJldHVybiByZXM7CiAgICAgICAgfQoKICAgICAgICByZXR1cm4gb3V0OwogICAgICB9IGNhdGNoIChlcnIpIHsKICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBldmFsdWF0aW5nIGV4cHJlc3Npb246JywgZXhwciwgdmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlCgogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICB9LAogICAgZXZhbHVhdGUocXVlc3Rpb24sIGFsbFF1ZXN0aW9ucykgewogICAgICBpZiAoICFxdWVzdGlvbi5zaG93X2lmICkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGNvbnN0IGFuZCA9IHF1ZXN0aW9uLnNob3dfaWYuc3BsaXQoJyYmJyk7CiAgICAgIGNvbnN0IG9yID0gcXVlc3Rpb24uc2hvd19pZi5zcGxpdCgnfHwnKTsKCiAgICAgIGxldCByZXN1bHQ7CgogICAgICBpZiAoIGdldChvciwgJ2xlbmd0aCcpID4gMSApIHsKICAgICAgICByZXN1bHQgPSBvci5zb21lKChzaG93SWYpID0+IHRoaXMuY2FsRXhwcmVzc2lvbihzaG93SWYsIGFsbFF1ZXN0aW9ucykpOwogICAgICB9IGVsc2UgewogICAgICAgIHJlc3VsdCA9IGFuZC5ldmVyeSgoc2hvd0lmKSA9PiB0aGlzLmNhbEV4cHJlc3Npb24oc2hvd0lmLCBhbGxRdWVzdGlvbnMpKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHJlc3VsdDsKICAgIH0sCiAgICBjYWxFeHByZXNzaW9uKHNob3dJZiwgYWxsUXVlc3Rpb25zKSB7CiAgICAgIGlmICggc2hvd0lmLmluY2x1ZGVzKCchPScpKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaXNOb3RFcXVhbChzaG93SWYsIGFsbFF1ZXN0aW9ucyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIHRoaXMuaXNFcXVhbChzaG93SWYsIGFsbFF1ZXN0aW9ucyk7CiAgICAgIH0KICAgIH0sCiAgICBpc0VxdWFsKHNob3dJZiwgYWxsUXVlc3Rpb25zKSB7CiAgICAgIHNob3dJZiA9IHNob3dJZi50cmltKCk7CiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKHNob3dJZiwgJz0nKTsKCiAgICAgIGlmICggdmFyaWFibGVzICkgewogICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLnN0cmluZ2lmeUFuc3dlcih0aGlzLmdldEFuc3dlcih2YXJpYWJsZXMubGVmdCwgYWxsUXVlc3Rpb25zKSk7CiAgICAgICAgY29uc3QgcmlnaHQgPSB0aGlzLnN0cmluZ2lmeUFuc3dlcih2YXJpYWJsZXMucmlnaHQpOwoKICAgICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQ7CiAgICAgIH0KCiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0sCiAgICBpc05vdEVxdWFsKHNob3dJZiwgYWxsUXVlc3Rpb25zKSB7CiAgICAgIHNob3dJZiA9IHNob3dJZi50cmltKCk7CiAgICAgIGNvbnN0IHZhcmlhYmxlcyA9IHRoaXMuZ2V0VmFyaWFibGVzKHNob3dJZiwgJyE9Jyk7CgogICAgICBpZiAoIHZhcmlhYmxlcyApIHsKICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5zdHJpbmdpZnlBbnN3ZXIodGhpcy5nZXRBbnN3ZXIodmFyaWFibGVzLmxlZnQsIGFsbFF1ZXN0aW9ucykpOwogICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5zdHJpbmdpZnlBbnN3ZXIodmFyaWFibGVzLnJpZ2h0KTsKCiAgICAgICAgcmV0dXJuIGxlZnQgIT09IHJpZ2h0OwogICAgICB9CgogICAgICByZXR1cm4gZmFsc2U7CiAgICB9LAogICAgZ2V0VmFyaWFibGVzKHNob3dJZiwgb3BlcmF0b3IpIHsKICAgICAgaWYgKCBzaG93SWYuaW5jbHVkZXMob3BlcmF0b3IpKSB7CiAgICAgICAgY29uc3QgYXJyYXkgPSBzaG93SWYuc3BsaXQob3BlcmF0b3IpOwoKICAgICAgICBpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMiApIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGxlZnQ6ICBhcnJheVswXSwKICAgICAgICAgICAgcmlnaHQ6IGFycmF5WzFdCiAgICAgICAgICB9OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIHJldHVybiBudWxsOwogICAgfSwKICAgIGdldEFuc3dlcih2YXJpYWJsZSwgcXVlc3Rpb25zKSB7CiAgICAgIGNvbnN0IGZvdW5kID0gcXVlc3Rpb25zLmZpbmQoKHEpID0+IHEudmFyaWFibGUgPT09IHZhcmlhYmxlKTsKCiAgICAgIGlmICggZm91bmQgKSB7CiAgICAgICAgLy8gRXF1aXZhbGVudCB0byBmaW5kaW5nIHF1ZXN0aW9uLmFuc3dlciBpbiBFbWJlcgogICAgICAgIHJldHVybiBnZXQodGhpcy52YWx1ZSwgZm91bmQudmFyaWFibGUpOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiB2YXJpYWJsZTsKICAgICAgfQogICAgfSwKICAgIHN0cmluZ2lmeUFuc3dlcihhbnN3ZXIpIHsKICAgICAgaWYgKCBhbnN3ZXIgPT09IHVuZGVmaW5lZCB8fCBhbnN3ZXIgPT09IG51bGwgKSB7CiAgICAgICAgcmV0dXJuICcnOwogICAgICB9IGVsc2UgaWYgKCB0eXBlb2YgYW5zd2VyID09PSAnc3RyaW5nJyApIHsKICAgICAgICByZXR1cm4gYW5zd2VyOwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBgJHsgYW5zd2VyIH1gOwogICAgICB9CiAgICB9LAogICAgc2hvdWxkU2hvdyhxLCB2YWx1ZXMpIHsKICAgICAgbGV0IGV4cHIgPSBxLmlmOwoKICAgICAgaWYgKCBleHByID09PSB1bmRlZmluZWQgJiYgcS5zaG93X2lmICE9PSB1bmRlZmluZWQgKSB7CiAgICAgICAgZXhwciA9IG1pZ3JhdGUocS5zaG93X2lmKTsKICAgICAgfQoKICAgICAgaWYgKCBleHByICkgewogICAgICAgIGNvbnN0IHNob3duID0gISF0aGlzLmV2YWxFeHByKGV4cHIsIHZhbHVlcywgcSwgdGhpcy5hbGxRdWVzdGlvbnMpOwoKICAgICAgICByZXR1cm4gc2hvd247CiAgICAgIH0KCiAgICAgIHJldHVybiB0cnVlOwogICAgfSwKICAgIHNob3VsZFNob3dTdWIocSwgdmFsdWVzKSB7CiAgICAgIC8vIFNpZ2gsIGJvdGggc2luZ3VsYXIgYW5kIHBsdXJhbCBhcmUgdXNlZCBpbiB0aGUgd2lsZC4uLgogICAgICBsZXQgZXhwciA9ICggcS5zdWJxdWVzdGlvbnNfaWYgPT09IHVuZGVmaW5lZCA/IHEuc3VicXVlc3Rpb25faWYgOiBxLnN1YnF1ZXN0aW9uc19pZik7CiAgICAgIGNvbnN0IG9sZCA9ICggcS5zaG93X3N1YnF1ZXN0aW9uc19pZiA9PT0gdW5kZWZpbmVkID8gcS5zaG93X3N1YnF1ZXN0aW9uX2lmIDogcS5zaG93X3N1YnF1ZXN0aW9uc19pZik7CgogICAgICBpZiAoICFleHByICYmIG9sZCAhPT0gdW5kZWZpbmVkICkgewogICAgICAgIGlmICggb2xkID09PSBmYWxzZSB8fCBvbGQgPT09ICdmYWxzZScgKSB7CiAgICAgICAgICBleHByID0gYCEkeyBxLnZhcmlhYmxlIH1gOwogICAgICAgIH0gZWxzZSBpZiAoIG9sZCA9PT0gdHJ1ZSB8fCBvbGQgPT09ICd0cnVlJyApIHsKICAgICAgICAgIGV4cHIgPSBgISEkeyBxLnZhcmlhYmxlIH1gOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBleHByID0gYCR7IHEudmFyaWFibGUgfSA9PSAiJHsgb2xkIH0iYDsKICAgICAgICB9CiAgICAgIH0KCiAgICAgIGlmICggZXhwciApIHsKICAgICAgICByZXR1cm4gdGhpcy5ldmFsRXhwcihleHByLCB2YWx1ZXMsIHEsIHRoaXMuYWxsUXVlc3Rpb25zKTsKICAgICAgfQoKICAgICAgcmV0dXJuIHRydWU7CiAgICB9CiAgfSwKfTsK"},{"version":3,"sources":["index.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"node_modules/@rancher/shell/components/Questions","sourcesContent":["<script>\nimport Jexl from 'jexl';\nimport Tab from '@shell/components/Tabbed/Tab';\nimport { get, set } from '@shell/utils/object';\nimport { sortBy, camelCase } from 'lodash';\nimport { _EDIT } from '@shell/config/query-params';\nimport StringType from './String';\nimport BooleanType from './Boolean';\nimport EnumType from './Enum';\nimport IntType from './Int';\nimport FloatType from './Float';\nimport ArrayType from './Array';\nimport MapType from './QuestionMap';\nimport ReferenceType from './Reference';\nimport CloudCredentialType from './CloudCredential';\nimport RadioType from './Radio';\nimport YamlType from './Yaml';\nimport Loading from '@shell/components/Loading';\n\nexport const knownTypes = {\n  string:          StringType,\n  hostname:        StringType,\n  multiline:       StringType,\n  password:        StringType,\n  ipaddr:          StringType,\n  cidr:            StringType,\n  cron:            StringType,\n  boolean:         BooleanType,\n  enum:            EnumType,\n  int:             IntType,\n  float:           FloatType,\n  questionMap:     MapType,\n  reference:       ReferenceType,\n  configmap:       ReferenceType,\n  secret:          ReferenceType,\n  storageclass:    ReferenceType,\n  pvc:             ReferenceType,\n  cloudcredential: CloudCredentialType,\n  radio:           RadioType,\n  yaml:            YamlType,\n};\n\nexport function componentForQuestion(q) {\n  const type = (q.type || '').toLowerCase();\n\n  if ( knownTypes[type] ) {\n    return type;\n  } else if ( type.startsWith('array[') ) { // This only really works for array[string|multiline], but close enough for now.\n    return ArrayType;\n  } else if ( type.startsWith('map[') ) { // Same, only works with map[string|multiline]\n    return MapType;\n  } else if ( type.startsWith('reference[') ) { // Same, only works with map[string|multiline]\n    return ReferenceType;\n  }\n\n  return 'string';\n}\n\nexport function schemaToQuestions(fields) {\n  const keys = Object.keys(fields);\n  const out = [];\n\n  for ( const k of keys ) {\n    out.push({\n      variable: k,\n      label:    k,\n      ...fields[k],\n    });\n  }\n\n  return out;\n}\n\nfunction migrate(expr) {\n  let out;\n\n  if ( expr.includes('||') ) {\n    out = expr.split('||').map((x) => migrate(x)).join(' || ');\n  } else if ( expr.includes('&&') ) {\n    out = expr.split('&&').map((x) => migrate(x)).join(' && ');\n  } else {\n    const parts = expr.match(/^(.*)(!?=)(.*)$/);\n\n    if ( parts ) {\n      const key = parts[1].trim();\n      const op = parts[2].trim() === '!=' ? '!=' : '==';\n      const val = parts[3].trim();\n\n      if ( val === 'true' || val === 'false' || val === 'null' ) {\n        out = `${ key } ${ op } ${ val }`;\n      } else if ( val === '' ) {\n        // Existing charts expect `foo=` with `{foo: null}` to be true.\n        if ( op === '!=' ) {\n          out = `!!${ key }`;\n        } else {\n          out = `!${ key }`;\n        }\n        // out = `${ op === '!' ? '!' : '' }(${ key } == \"\" || ${ key } == null)`;\n      } else {\n        out = `${ key } ${ op } \"${ val }\"`;\n      }\n    } else {\n      try {\n        Jexl.compile(expr);\n\n        out = expr;\n      } catch (e) {\n        console.error('Error migrating expression:', expr); // eslint-disable-line no-console\n\n        out = 'true';\n      }\n    }\n  }\n\n  return out;\n}\n\nexport default {\n  components: {\n    ...knownTypes,\n    Tab,\n    Loading,\n  },\n\n  props: {\n    mode: {\n      type:    String,\n      default: _EDIT,\n    },\n\n    value: {\n      type:     Object,\n      required: true,\n    },\n\n    tabbed: {\n      type:    [Boolean, String],\n      default: true,\n    },\n\n    // Can be a chartVersion, resource Schema, or an Array of question objects\n    source: {\n      type:     [Object, Array],\n      required: true,\n    },\n\n    targetNamespace: {\n      type:     String,\n      required: true\n    },\n\n    ignoreVariables: {\n      type:    Array,\n      default: () => [],\n    },\n\n    disabled: {\n      type:    Boolean,\n      default: false,\n    },\n\n    inStore: {\n      type:    String,\n      default: 'cluster'\n    },\n\n    emit: {\n      type:    Boolean,\n      default: false,\n    }\n  },\n\n  async fetch() {\n    // If this source is a schema, ensure the schema's `resourceFields` is populated\n    if (this.source.type === 'schema' && this.source.requiresResourceFields) {\n      await this.source.fetchResourceFields();\n    }\n  },\n\n  data() {\n    return { valueGeneration: 0 };\n  },\n\n  computed: {\n    allQuestions() {\n      if ( this.source.questions?.questions ) {\n        return this.source.questions.questions;\n      } else if ( this.source.type === 'schema' && this.source.resourceFields ) {\n        return schemaToQuestions(this.source.resourceFields);\n      } else if ( typeof this.source === 'object' ) {\n        return schemaToQuestions(this.source);\n      } else {\n        return [];\n      }\n    },\n\n    shownQuestions() {\n      const values = this.value;\n      const vm = this;\n\n      if ( this.valueGeneration < 0 ) {\n        // Pointless condition to get this to depend on generation and recompute\n        return;\n      }\n\n      const out = [];\n\n      for ( const q of this.allQuestions ) {\n        if ( this.ignoreVariables.includes(q.variable) ) {\n          continue;\n        }\n\n        addQuestion(q);\n      }\n\n      return out;\n\n      function addQuestion(q, depth = 1, parentGroup) {\n        if ( !vm.shouldShow(q, values) ) {\n          return;\n        }\n\n        q.depth = depth;\n        q.group = q.group || parentGroup;\n\n        out.push(q);\n\n        if ( q.subquestions?.length && vm.shouldShowSub(q, values) ) {\n          for ( const sub of q.subquestions ) {\n            addQuestion(sub, depth + 1, q.group);\n          }\n        }\n      }\n    },\n\n    chartName() {\n      return this.source.chart?.name;\n    },\n\n    groups() {\n      const map = {};\n      const defaultGroup = 'Questions';\n      let weight = this.shownQuestions.length;\n\n      for ( const q of this.shownQuestions ) {\n        const group = q.group || defaultGroup;\n\n        const normalized = group.trim().toLowerCase();\n        const name = this.$store.getters['i18n/withFallback'](`charts.${ this.chartName }.group.${ camelCase(group) }`, null, group);\n\n        if ( !map[normalized] ) {\n          map[normalized] = {\n            name,\n            questions: [],\n            weight:    weight--,\n          };\n        }\n\n        map[normalized].questions.push(q);\n      }\n\n      const out = Object.values(map);\n\n      return sortBy(out, 'weight:desc');\n    },\n\n    asTabs() {\n      if ( this.tabbed === false || this.tabbed === 'never' ) {\n        return false;\n      }\n\n      if ( this.tabbed === 'multiple' ) {\n        return !!this.groups.length;\n      }\n\n      return true;\n    },\n  },\n\n  watch: {\n    value: {\n      deep: true,\n\n      handler() {\n        this.valueGeneration++;\n      },\n    }\n  },\n\n  methods: {\n    get,\n    set,\n    componentForQuestion,\n\n    update(variable, $event) {\n      set(this.value, variable, $event);\n      if (this.emit) {\n        this.$emit('updated');\n      }\n    },\n    evalExpr(expr, values, question, allQuestions) {\n      try {\n        const out = Jexl.evalSync(expr, values);\n\n        // console.log('Eval', expr, '=> ', out);\n\n        // If the variable contains a hyphen, check if it evaluates to true\n        // according to the evaluation logic used in the old UI.\n        // This helps users avoid manual work to migrate from legacy apps.\n        if (!out && expr.includes('-')) {\n          const res = this.evaluate(question, allQuestions);\n\n          return res;\n        }\n\n        return out;\n      } catch (err) {\n        console.error('Error evaluating expression:', expr, values); // eslint-disable-line no-console\n\n        return true;\n      }\n    },\n    evaluate(question, allQuestions) {\n      if ( !question.show_if ) {\n        return true;\n      }\n      const and = question.show_if.split('&&');\n      const or = question.show_if.split('||');\n\n      let result;\n\n      if ( get(or, 'length') > 1 ) {\n        result = or.some((showIf) => this.calExpression(showIf, allQuestions));\n      } else {\n        result = and.every((showIf) => this.calExpression(showIf, allQuestions));\n      }\n\n      return result;\n    },\n    calExpression(showIf, allQuestions) {\n      if ( showIf.includes('!=')) {\n        return this.isNotEqual(showIf, allQuestions);\n      } else {\n        return this.isEqual(showIf, allQuestions);\n      }\n    },\n    isEqual(showIf, allQuestions) {\n      showIf = showIf.trim();\n      const variables = this.getVariables(showIf, '=');\n\n      if ( variables ) {\n        const left = this.stringifyAnswer(this.getAnswer(variables.left, allQuestions));\n        const right = this.stringifyAnswer(variables.right);\n\n        return left === right;\n      }\n\n      return false;\n    },\n    isNotEqual(showIf, allQuestions) {\n      showIf = showIf.trim();\n      const variables = this.getVariables(showIf, '!=');\n\n      if ( variables ) {\n        const left = this.stringifyAnswer(this.getAnswer(variables.left, allQuestions));\n        const right = this.stringifyAnswer(variables.right);\n\n        return left !== right;\n      }\n\n      return false;\n    },\n    getVariables(showIf, operator) {\n      if ( showIf.includes(operator)) {\n        const array = showIf.split(operator);\n\n        if ( array.length === 2 ) {\n          return {\n            left:  array[0],\n            right: array[1]\n          };\n        } else {\n          return null;\n        }\n      }\n\n      return null;\n    },\n    getAnswer(variable, questions) {\n      const found = questions.find((q) => q.variable === variable);\n\n      if ( found ) {\n        // Equivalent to finding question.answer in Ember\n        return get(this.value, found.variable);\n      } else {\n        return variable;\n      }\n    },\n    stringifyAnswer(answer) {\n      if ( answer === undefined || answer === null ) {\n        return '';\n      } else if ( typeof answer === 'string' ) {\n        return answer;\n      } else {\n        return `${ answer }`;\n      }\n    },\n    shouldShow(q, values) {\n      let expr = q.if;\n\n      if ( expr === undefined && q.show_if !== undefined ) {\n        expr = migrate(q.show_if);\n      }\n\n      if ( expr ) {\n        const shown = !!this.evalExpr(expr, values, q, this.allQuestions);\n\n        return shown;\n      }\n\n      return true;\n    },\n    shouldShowSub(q, values) {\n      // Sigh, both singular and plural are used in the wild...\n      let expr = ( q.subquestions_if === undefined ? q.subquestion_if : q.subquestions_if);\n      const old = ( q.show_subquestions_if === undefined ? q.show_subquestion_if : q.show_subquestions_if);\n\n      if ( !expr && old !== undefined ) {\n        if ( old === false || old === 'false' ) {\n          expr = `!${ q.variable }`;\n        } else if ( old === true || old === 'true' ) {\n          expr = `!!${ q.variable }`;\n        } else {\n          expr = `${ q.variable } == \"${ old }\"`;\n        }\n      }\n\n      if ( expr ) {\n        return this.evalExpr(expr, values, q, this.allQuestions);\n      }\n\n      return true;\n    }\n  },\n};\n</script>\n\n<template>\n  <Loading\n    v-if=\"$fetchState.pending\"\n    mode=\"relative\"\n  />\n  <form v-else-if=\"asTabs\">\n    <Tab\n      v-for=\"g in groups\"\n      :key=\"g.name\"\n      :name=\"g.name\"\n      :label=\"g.name\"\n      :weight=\"g.weight\"\n    >\n      <div\n        v-for=\"q in g.questions\"\n        :key=\"q.variable\"\n        class=\"row question\"\n      >\n        <div class=\"col span-12\">\n          <component\n            :is=\"componentForQuestion(q)\"\n            :in-store=\"inStore\"\n            :question=\"q\"\n            :target-namespace=\"targetNamespace\"\n            :value=\"get(value, q.variable)\"\n            :disabled=\"disabled\"\n            :chart-name=\"chartName\"\n            @input=\"update(q.variable, $event)\"\n          />\n        </div>\n      </div>\n    </Tab>\n  </form>\n  <form v-else>\n    <div\n      v-for=\"g in groups\"\n      :key=\"g.name\"\n    >\n      <h3 v-if=\"groups.length > 1\">\n        {{ g.label }}\n      </h3>\n      <div\n        v-for=\"q in g.questions\"\n        :key=\"q.variable\"\n        class=\"row question\"\n      >\n        <div class=\"col span-12\">\n          <component\n            :is=\"componentForQuestion(q)\"\n            :in-store=\"inStore\"\n            :question=\"q\"\n            :target-namespace=\"targetNamespace\"\n            :mode=\"mode\"\n            :value=\"get(value, q.variable)\"\n            :disabled=\"disabled\"\n            :chart-name=\"chartName\"\n            @input=\"update(q.variable, $event)\"\n          />\n        </div>\n      </div>\n    </div>\n  </form>\n</template>\n\n<style lang=\"scss\" scoped>\n  .question {\n    margin-top: 10px;\n\n    &:first-child {\n      margin-top: 0;\n    }\n  }\n</style>\n"]}]}
{"remainingRequest":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/ubuntu/susecon-2024-ext-demo/node_modules/@rancher/shell/edit/provisioning.cattle.io.cluster/index.vue?vue&type=style&index=0&id=d4f0724c&lang=scss","dependencies":[{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@rancher/shell/edit/provisioning.cattle.io.cluster/index.vue","mtime":1725271280091},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1725271300564},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1725271300920},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/postcss-loader/src/index.js","mtime":1725271300857},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/sass-loader/dist/cjs.js","mtime":1725271288422},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/cache-loader/dist/cjs.js","mtime":1725271299021},{"path":"/home/ubuntu/susecon-2024-ext-demo/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1725271300920}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci5ncm91cGVkLXR5cGUgewogIHBvc2l0aW9uOiByZWxhdGl2ZTsKfQoKLnJrZS1zd2l0Y2ggewogIG1hcmdpbi10b3A6IC0xMHB4OwogIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICByaWdodDogMDsKfQo="},{"version":3,"sources":["index.vue"],"names":[],"mappings":";AAuqBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"index.vue","sourceRoot":"node_modules/@rancher/shell/edit/provisioning.cattle.io.cluster","sourcesContent":["<script>\nimport CreateEditView from '@shell/mixins/create-edit-view';\nimport Loading from '@shell/components/Loading';\nimport CruResource from '@shell/components/CruResource';\nimport SelectIconGrid from '@shell/components/SelectIconGrid';\nimport EmberPage from '@shell/components/EmberPage';\nimport { ToggleSwitch } from '@components/Form/ToggleSwitch';\nimport {\n  CHART, FROM_CLUSTER, SUB_TYPE, RKE_TYPE, _EDIT, _IMPORT, _CONFIG, _VIEW\n} from '@shell/config/query-params';\nimport { mapGetters } from 'vuex';\nimport { sortBy } from '@shell/utils/sort';\nimport { set } from '@shell/utils/object';\nimport { PROVISIONER, _RKE1, _RKE2 } from '@shell/store/prefs';\nimport { filterAndArrangeCharts } from '@shell/store/catalog';\nimport { CATALOG } from '@shell/config/labels-annotations';\nimport { CAPI, MANAGEMENT, DEFAULT_WORKSPACE } from '@shell/config/types';\nimport { mapFeature, RKE2 as RKE2_FEATURE, RKE1_UI } from '@shell/store/features';\nimport { allHash } from '@shell/utils/promise';\nimport { BLANK_CLUSTER } from '@shell/store/store-types.js';\nimport { ELEMENTAL_PRODUCT_NAME, ELEMENTAL_CLUSTER_PROVIDER } from '../../config/elemental-types';\nimport Rke2Config from './rke2';\nimport Import from './import';\n\nconst SORT_GROUPS = {\n  template:  1,\n  kontainer: 2,\n  rke1:      3,\n  rke2:      3,\n  register:  4,\n  custom:    5,\n  custom1:   5,\n  custom2:   5,\n};\n\n// uSed to proxy stylesheets for custom drivers that provide custom UI (RKE1)\nconst PROXY_ENDPOINT = '/meta/proxy';\n\nexport default {\n  name: 'CruCluster',\n\n  components: {\n    CruResource,\n    EmberPage,\n    Import,\n    Loading,\n    Rke2Config,\n    SelectIconGrid,\n    ToggleSwitch\n  },\n\n  mixins: [CreateEditView],\n\n  props: {\n    realMode: {\n      type:     String,\n      required: true,\n    },\n\n    mode: {\n      type:     String,\n      required: true,\n    },\n\n    value: {\n      type:    Object,\n      default: null,\n    },\n\n    /**\n     * Inherited global identifier prefix for tests\n     * Define a term based on the parent component to avoid conflicts on multiple components\n     */\n    componentTestid: {\n      type:    String,\n      default: 'cluster-manager-create'\n    }\n  },\n\n  async fetch() {\n    const hash = {\n      // These aren't explicitly used, but need to be listening for change events\n      mgmtClusters: this.$store.dispatch('management/findAll', { type: MANAGEMENT.CLUSTER }),\n      provClusters: this.$store.dispatch('management/findAll', { type: CAPI.RANCHER_CLUSTER }),\n\n      catalog: this.$store.dispatch('catalog/load'),\n    };\n\n    if (this.$store.getters[`management/canList`](MANAGEMENT.NODE_DRIVER)) {\n      hash.nodeDrivers = this.$store.dispatch('management/findAll', { type: MANAGEMENT.NODE_DRIVER });\n    }\n\n    if (this.$store.getters[`management/canList`](MANAGEMENT.KONTAINER_DRIVER)) {\n      hash.kontainerDrivers = this.$store.dispatch('management/findAll', { type: MANAGEMENT.KONTAINER_DRIVER });\n    }\n\n    if ( this.value.id && !this.value.isRke2 ) {\n      // These are needed to resolve references in the mgmt cluster -> node pool -> node template to figure out what provider the cluster is using\n      // so that the edit iframe for ember pages can go to the right place.\n      if (this.$store.getters[`management/canList`](MANAGEMENT.NODE_POOL)) {\n        hash.rke1NodePools = this.$store.dispatch('management/findAll', { type: MANAGEMENT.NODE_POOL });\n      }\n\n      if (this.$store.getters[`management/canList`](MANAGEMENT.NODE_TEMPLATE)) {\n        hash.rke1NodeTemplates = this.$store.dispatch('management/findAll', { type: MANAGEMENT.NODE_TEMPLATE });\n      }\n    }\n\n    const res = await allHash(hash);\n\n    this.nodeDrivers = res.nodeDrivers || [];\n    this.kontainerDrivers = res.kontainerDrivers || [];\n\n    if ( !this.value.spec ) {\n      set(this.value, 'spec', {});\n    }\n\n    if ( !this.value.id ) {\n      if ( !this.value.metadata ) {\n        set(this.value, 'metadata', {});\n      }\n\n      set(this.value.metadata, 'namespace', DEFAULT_WORKSPACE);\n    }\n\n    // For the node drivers, look for custom UI that we can use to show an icon (if not built-in)\n    this.nodeDrivers.forEach((driver) => {\n      if (!driver.spec?.builtin && driver.spec?.uiUrl && driver.spec?.active) {\n        const name = driver.spec?.displayName || driver.id;\n        let cssUrl = driver.spec.uiUrl.replace(/\\.js$/, '.css');\n\n        if (cssUrl.startsWith('http://') || cssUrl.startsWith('https://')) {\n          cssUrl = `${ PROXY_ENDPOINT }/${ cssUrl }`;\n        }\n\n        this.loadStylesheet(cssUrl, `driver-ui-css-${ driver.id }`);\n\n        this.iconClasses[name] = `machine-driver ${ name }`;\n      }\n    });\n\n    // Custom Providers from extensions - initialize each with the store and the i18n service\n    // Wrap in try ... catch, to prevent errors in an extension breaking the page\n    try {\n      const extensionClasses = this.$plugin.listDynamic('provisioner').map((name) => this.$plugin.getDynamic('provisioner', name));\n\n      // We can't pass in this.$store as this leads to a circular-reference that causes Vue to freeze,\n      // so pass in specific services that the provisioner extension may need\n      this.extensions = extensionClasses.map((c) => new c({\n        dispatch: this.$store.dispatch,\n        getters:  this.$store.getters,\n        axios:    this.$store.$axios,\n        $plugin:  this.$store.app.$plugin,\n        t:        (...args) => this.t.apply(this, args),\n        isCreate: this.isCreate,\n        isEdit:   this.isEdit,\n        isView:   this.isView,\n      }));\n    } catch (e) {\n      console.error('Error loading provisioner(s) from extensions', e); // eslint-disable-line no-console\n    }\n  },\n\n  data() {\n    const subType = this.$route.query[SUB_TYPE] || null;\n    const rkeType = this.$route.query[RKE_TYPE] || null;\n    const chart = this.$route.query[CHART] || null;\n    const isImport = this.realMode === _IMPORT;\n\n    return {\n      nodeDrivers:      [],\n      kontainerDrivers: [],\n      extensions:       [],\n      subType,\n      rkeType,\n      chart,\n      isImport,\n      providerCluster:  null,\n      iconClasses:      {},\n    };\n  },\n\n  computed: {\n    ...mapGetters({ allCharts: 'catalog/charts' }),\n    ...mapGetters('type-map', ['activeProducts']),\n    // needed to recreate logic on mapPref in order to incorporate the logic around the rkeType query param\n    // https://github.com/rancher/dashboard/issues/6299\n    preferredProvisioner: {\n      get() {\n        if (this.rkeType) {\n          return this.rkeType;\n        }\n\n        return this.$store.getters['prefs/get'](PROVISIONER);\n      },\n      set(value) {\n        this.$store.dispatch('prefs/set', { key: PROVISIONER, value });\n      }\n    },\n    _RKE1: () => _RKE1,\n    _RKE2: () => _RKE2,\n\n    emberLink() {\n      if (this.value) {\n        if (this.value.provisioner) {\n          const matchingSubtype = this.subTypes.find((st) => st.id.toLowerCase() === this.value.provisioner.toLowerCase());\n\n          if (matchingSubtype) {\n            this.selectType(matchingSubtype.id, false);\n          }\n        }\n        // For custom RKE2 clusters, don't load an Ember page.\n        // It should be the dashboard.\n        if ( this.value.isRke2 && ((this.value.isCustom && this.mode === _EDIT) || (this.value.isCustom && this.as === _CONFIG && this.mode === _VIEW) || (this.subType || '').toLowerCase() === 'custom')) {\n          // For admins, this.value.isCustom is used to check if it is a custom cluster.\n          // For cluster owners, this.subtype is used.\n          this.selectType('custom', false);\n\n          return '';\n        }\n        // For RKE2/K3s clusters provisioned in Rancher with node pools,\n        // do not use an iFramed Ember page.\n        if ( this.value.isRke2 && this.value.machineProvider ) {\n          // Edit existing RKE2\n          this.selectType(this.value.machineProvider, false);\n\n          return '';\n        }\n        if ( this.subType ) {\n          // if driver type has a custom form component, don't load an ember page\n          if (this.selectedSubType.component) {\n            return '';\n          }\n          // For RKE1 and hosted Kubernetes Clusters, set the ember link\n          // so that we load the page rather than using RKE2 create\n          if (this.selectedSubType?.emberLink) {\n            return this.selectedSubType.emberLink;\n          }\n\n          this.selectType(this.subType, false);\n\n          return '';\n        }\n\n        if ( this.value.mgmt?.emberEditPath ) {\n          // Iframe an old page\n          return this.value.mgmt.emberEditPath;\n        }\n      }\n\n      return '';\n    },\n\n    rke2Enabled:   mapFeature(RKE2_FEATURE),\n    rke1UiEnabled: mapFeature(RKE1_UI),\n\n    // todo nb is this info stored anywhere else..?\n    selectedSubType() {\n      return this.subType ? this.subTypes.find((s) => s.id === this.subType) : null;\n    },\n\n    provisioner: {\n      get() {\n        // This can incorrectly return rke1 instead\n        // of rke2 for cluster owners.\n        if ( !this.rke2Enabled ) {\n          return _RKE1;\n        }\n\n        if ( !this.rke1UiEnabled ) {\n          return _RKE2;\n        }\n\n        return this.preferredProvisioner;\n      },\n\n      set(neu) {\n        this.preferredProvisioner = neu;\n      },\n    },\n\n    isRke1() {\n      return this.provisioner === _RKE1;\n    },\n\n    isRke2() {\n      return this.value.isRke2 || !this.isRke1;\n    },\n\n    templateOptions() {\n      if ( !this.rke2Enabled ) {\n        return [];\n      }\n\n      const out = filterAndArrangeCharts(this.allCharts, { showTypes: CATALOG._CLUSTER_TPL });\n\n      return out;\n    },\n\n    subTypes() {\n      const getters = this.$store.getters;\n      const isImport = this.isImport;\n      const isElementalActive = !!this.activeProducts.find((item) => item.name === ELEMENTAL_PRODUCT_NAME);\n      let out = [];\n\n      const templates = this.templateOptions;\n      const vueKontainerTypes = getters['plugins/clusterDrivers'];\n      const machineTypes = this.nodeDrivers.filter((x) => x.spec.active && x.state === 'active');\n\n      this.kontainerDrivers.filter((x) => (isImport ? x.showImport : x.showCreate)).forEach((obj) => {\n        if ( vueKontainerTypes.includes(obj.driverName) ) {\n          addType(obj.driverName, 'kontainer', false);\n        } else {\n          addType(obj.driverName, 'kontainer', false, (isImport ? obj.emberImportPath : obj.emberCreatePath));\n        }\n      });\n\n      if ( isImport ) {\n        addType('import', 'custom', false);\n      } else {\n        templates.forEach((chart) => {\n          out.push({\n            id:          `chart:${ chart.id }`,\n            label:       chart.chartNameDisplay,\n            description: chart.chartDescription,\n            icon:        chart.icon || require('~shell/assets/images/generic-catalog.svg'),\n            group:       'template',\n            tag:         getters['i18n/t']('generic.techPreview')\n          });\n        });\n\n        if (this.isRke1 ) {\n          machineTypes.forEach((type) => {\n            const id = type.spec.displayName || type.id;\n\n            addType(id, _RKE1, false, `/g/clusters/add/launch/${ id }`, this.iconClasses[id], type);\n          });\n\n          addType('custom', 'custom1', false, '/g/clusters/add/launch/custom');\n        } else {\n          machineTypes.forEach((type) => {\n            const id = type.spec.displayName || type.id;\n\n            addType(id, _RKE2, false, null, undefined, type);\n          });\n\n          addType('custom', 'custom2', false);\n\n          if (isElementalActive) {\n            addType(ELEMENTAL_CLUSTER_PROVIDER, 'custom2', false);\n          }\n        }\n\n        // Add from extensions\n        this.extensions.forEach((ext) => {\n          // if the rke toggle is set to rke1, don't add extensions that specify rke2 group\n          // default group is rke2\n          if (!this.isRke2 && (ext.group === _RKE2 || !ext.group)) {\n            return;\n          }\n          // Do not show the extension provisioner on the import cluster page unless its explicitly set to do so\n          if (isImport && !ext.showImport) {\n            return;\n          }\n          // Allow extensions to overwrite provisioners with the same id\n          out = out.filter((type) => type.id !== ext.id);\n          addExtensionType(ext, getters);\n        });\n      }\n\n      return out;\n\n      function addExtensionType(ext, getters) {\n        let iconClass = ext.iconClass;\n        let icon = ext.icon;\n\n        if (icon) {\n          iconClass = undefined;\n        } else if (!iconClass) {\n          icon = require('~shell/assets/images/generic-driver.svg');\n        }\n\n        const subtype = {\n          id:          ext.id,\n          label:       ext.label || getters['i18n/t'](`cluster.provider.${ ext.id }`),\n          description: ext.description,\n          icon,\n          iconClass,\n          group:       ext.group || _RKE2,\n          disabled:    ext.disabled || false,\n          link:        ext.link,\n          tag:         ext.tag,\n          component:   ext.component\n        };\n\n        out.push(subtype);\n      }\n\n      function addType(id, group, disabled = false, emberLink = null, iconClass = undefined, providerConfig = undefined) {\n        const label = getters['i18n/withFallback'](`cluster.provider.\"${ id }\"`, null, id);\n        const description = getters['i18n/withFallback'](`cluster.providerDescription.\"${ id }\"`, null, '');\n        const tag = '';\n\n        let icon;\n\n        try {\n          icon = require(`~shell/assets/images/providers/${ id }.svg`);\n        } catch (e) {}\n\n        if (icon) {\n          iconClass = undefined;\n        } else if (!iconClass) {\n          icon = require('~shell/assets/images/generic-driver.svg');\n        }\n\n        const subtype = {\n          id,\n          label,\n          description,\n          icon,\n          iconClass,\n          group,\n          disabled,\n          emberLink,\n          tag,\n          providerConfig\n        };\n\n        out.push(subtype);\n      }\n    },\n\n    groupedSubTypes() {\n      const out = {};\n\n      for ( const row of this.subTypes ) {\n        const name = row.group;\n        let entry = out[name];\n\n        if ( !entry ) {\n          entry = {\n            name,\n            label: this.$store.getters['i18n/withFallback'](`cluster.providerGroup.\"${ this.isImport ? 'register-' : 'create-' }${ name }\"`, null, name),\n            types: [],\n            sort:  SORT_GROUPS[name],\n          };\n\n          out[name] = entry;\n        }\n\n        entry.types.push(row);\n      }\n\n      for ( const k in out ) {\n        out[k].types = sortBy(out[k].types, 'label');\n      }\n\n      return sortBy(Object.values(out), 'sort');\n    },\n\n    firstNodeDriverItem() {\n      return this.groupedSubTypes.findIndex((obj) => [_RKE1, _RKE2].includes(obj.name));\n    },\n\n    firstCustomClusterItem() {\n      return this.groupedSubTypes.findIndex((obj) => ['custom', 'custom1', 'custom2'].includes(obj.name));\n    },\n  },\n\n  methods: {\n    showRkeToggle(i) {\n      if (this.isImport || !this.rke2Enabled) {\n        return false;\n      }\n\n      if (this.firstNodeDriverItem >= 0) {\n        return i === this.firstNodeDriverItem;\n      }\n\n      return i === this.firstCustomClusterItem;\n    },\n\n    loadStylesheet(url, id) {\n      if ( !id ) {\n        console.error('loadStylesheet called without an id'); // eslint-disable-line no-console\n\n        return;\n      }\n\n      // Check if the stylesheet has already been loaded\n      if ( $(`#${id}`).length > 0 ) { // eslint-disable-line\n        return;\n      }\n\n      const link = document.createElement('link');\n\n      link.onerror = () => {\n        link.remove();\n      };\n      link.rel = 'stylesheet';\n      link.src = url;\n      link.href = url;\n      link.id = id;\n      document.getElementsByTagName('HEAD')[0].appendChild(link);\n    },\n\n    cancel() {\n      this.$router.push({\n        name:   'c-cluster-product-resource',\n        params: {\n          cluster:  this.$route.params.cluster,\n          product:  this.$store.getters['productId'],\n          resource: CAPI.RANCHER_CLUSTER,\n        },\n      });\n    },\n\n    colorFor(obj) {\n      return `color${ SORT_GROUPS[obj.group] || 1 }`;\n    },\n\n    clickedType(obj) {\n      const id = obj.id;\n      const parts = id.split(':', 2);\n\n      if ( parts[0] === 'chart' ) {\n        const chart = this.$store.getters['catalog/chart']({ key: parts[1] });\n        let localCluster;\n\n        if (this.$store.getters[`management/canList`](MANAGEMENT.CLUSTER)) {\n          localCluster = this.$store.getters['management/all'](MANAGEMENT.CLUSTER).find((x) => x.isLocal);\n        }\n\n        chart.goToInstall(FROM_CLUSTER, localCluster?.id || BLANK_CLUSTER, true);\n\n        return;\n      }\n      if (obj.link) {\n        this.$router.push(obj.link);\n\n        return;\n      }\n\n      this.$router.applyQuery({ [SUB_TYPE]: id, [RKE_TYPE]: this.preferredProvisioner });\n      this.selectType(id);\n    },\n\n    selectType(type, fetch = true) {\n      const parts = type.split(':', 2);\n\n      if ( parts[0] === 'chart' ) {\n        this.subType = 'chart';\n        this.$emit('set-subtype', this.$store.getters['i18n/withFallback'](`cluster.provider.chart`));\n      } else {\n        this.subType = type;\n        this.$emit('set-subtype', this.$store.getters['i18n/withFallback'](`cluster.provider.\"${ type }\"`, null, type));\n      }\n\n      if ( fetch ) {\n        this.$fetch();\n      }\n    },\n  },\n};\n</script>\n\n<template>\n  <Loading v-if=\"$fetchState.pending\" />\n  <div\n    v-else-if=\"emberLink\"\n    class=\"embed\"\n  >\n    <EmberPage\n      :force-new=\"true\"\n      :src=\"emberLink\"\n    />\n  </div>\n  <CruResource\n    v-else\n    :mode=\"mode\"\n    :validation-passed=\"true\"\n    :selected-subtype=\"subType\"\n    :resource=\"value\"\n    :errors=\"errors\"\n    :subtypes=\"subTypes\"\n    :cancel-event=\"true\"\n    :prevent-enter-submit=\"true\"\n    class=\"create-cluster\"\n    @finish=\"save\"\n    @cancel=\"cancel\"\n    @select-type=\"selectType\"\n    @error=\"e=>errors = e\"\n  >\n    <template #subtypes>\n      <div\n        v-for=\"(obj, i) in groupedSubTypes\"\n        :key=\"obj.id\"\n        class=\"mb-20\"\n        style=\"width: 100%;\"\n      >\n        <h4>\n          <div\n            v-if=\"showRkeToggle(i) && rke1UiEnabled\"\n            class=\"grouped-type\"\n          >\n            <ToggleSwitch\n              v-model=\"provisioner\"\n              data-testid=\"cluster-manager-create-rke-switch\"\n              class=\"rke-switch\"\n              :off-value=\"_RKE1\"\n              :off-label=\"t('cluster.toggle.v1')\"\n              :on-value=\"_RKE2\"\n              :on-label=\"t('cluster.toggle.v2')\"\n            />\n          </div>\n          {{ obj.label }}\n        </h4>\n        <SelectIconGrid\n          :rows=\"obj.types\"\n          key-field=\"id\"\n          name-field=\"label\"\n          side-label-field=\"tag\"\n          :color-for=\"colorFor\"\n          :component-testid=\"'cluster-manager-create-grid-' + i\"\n          @clicked=\"clickedType\"\n        />\n      </div>\n    </template>\n\n    <Import\n      v-if=\"isImport\"\n      v-model=\"value\"\n      :mode=\"mode\"\n      :provider=\"subType\"\n    />\n    <template v-else-if=\"subType\">\n      <!-- allow extensions to provide their own cluster provisioning form -->\n      <component\n        :is=\"selectedSubType.component\"\n        v-if=\"selectedSubType && selectedSubType.component\"\n        v-model=\"value\"\n        :initial-value=\"initialValue\"\n        :live-value=\"liveValue\"\n        :mode=\"mode\"\n        :provider=\"subType\"\n        :provider-config=\"selectedSubType.providerConfig\"\n      />\n      <Rke2Config\n        v-else\n        v-model=\"value\"\n        :initial-value=\"initialValue\"\n        :live-value=\"liveValue\"\n        :mode=\"mode\"\n        :provider=\"subType\"\n        :provider-config=\"selectedSubType.providerConfig\"\n      />\n    </template>\n\n    <template\n      v-if=\"subType\"\n      #form-footer\n    >\n      <div><!-- Hide the outer footer --></div>\n    </template>\n  </CruResource>\n</template>\n\n<style lang='scss'>\n  .grouped-type {\n    position: relative;\n  }\n\n  .rke-switch {\n    margin-top: -10px;\n    position: absolute;\n    right: 0;\n  }\n</style>\n"]}]}
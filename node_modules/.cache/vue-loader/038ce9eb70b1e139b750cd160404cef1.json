{"remainingRequest":"/home/ubuntu/suseconf/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/ubuntu/suseconf/node_modules/@rancher/shell/list/node.vue?vue&type=style&index=0&id=1b9debdd&lang=scss&scoped=true","dependencies":[{"path":"/home/ubuntu/suseconf/node_modules/@rancher/shell/list/node.vue","mtime":1725338146566},{"path":"/home/ubuntu/suseconf/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1725271300564},{"path":"/home/ubuntu/suseconf/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1725271300920},{"path":"/home/ubuntu/suseconf/node_modules/postcss-loader/src/index.js","mtime":1725271300857},{"path":"/home/ubuntu/suseconf/node_modules/sass-loader/dist/cjs.js","mtime":1725271288422},{"path":"/home/ubuntu/suseconf/node_modules/cache-loader/dist/cjs.js","mtime":1725271299021},{"path":"/home/ubuntu/suseconf/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1725271300920}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoubGFiZWxzIHsKICAgIGRpc3BsYXk6IGlubGluZTsKICAgIGZsZXgtd3JhcDogd3JhcDsKCiAgICAubGFiZWwgewogICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgICAgIG1hcmdpbi10b3A6IDJweDsKICAgIH0KCn0KLnRhaW50cyB7CiAgdGQgewogICAgcGFkZGluZy10b3A6MDsKICAgIC50YWcgewogICAgICBtYXJnaW4tcmlnaHQ6IDVweDsKICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogICAgICBtYXJnaW4tdG9wOiAycHg7CiAgICB9CiAgfQogICYuZW1wdHktdGFpbnRzIHsKICAgIC8vIE5vIHRhaW50cy4uLiBzbyBoaWRlIHN1Yi1yb3cgKGJ1dCBub3QgYm90dG9tLWJvcmRlcikKICAgIGhlaWdodDogMDsKICAgIGxpbmUtaGVpZ2h0OiAwOwogICAgdGQgewogICAgICBwYWRkaW5nOiAwOwogICAgfQogIH0KfQoK"},{"version":3,"sources":["node.vue"],"names":[],"mappings":";;AAyXA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"node.vue","sourceRoot":"node_modules/@rancher/shell/list","sourcesContent":["<script lang=\"ts\">\nimport ResourceTable from '@shell/components/ResourceTable.vue';\nimport Tag from '@shell/components/Tag.vue';\nimport { Banner } from '@components/Banner';\nimport { PODS } from '@shell/config/table-headers';\nimport metricPoller from '@shell/mixins/metric-poller';\n\nimport { CAPI as CAPI_ANNOTATIONS } from '@shell/config/labels-annotations.js';\n\nimport { defineComponent } from 'vue';\nimport { ActionFindPageArgs } from '@shell/types/store/dashboard-store.types';\nimport { FilterArgs, PaginationFilterField, PaginationParamFilter } from '@shell/types/store/pagination.types';\n\nimport {\n  CAPI,\n  MANAGEMENT, METRIC, NODE, NORMAN, POD\n} from '@shell/config/types';\nimport { allHash } from '@shell/utils/promise';\nimport { GROUP_RESOURCES, mapPref } from '@shell/store/prefs';\nimport { COLUMN_BREAKPOINTS } from '@shell/types/store/type-map';\n\nimport ResourceFetch from '@shell/mixins/resource-fetch';\nimport { mapGetters } from 'vuex';\n\nexport default defineComponent({\n  name:       'ListNode',\n  components: {\n    ResourceTable,\n    Tag,\n    Banner\n  },\n  mixins: [metricPoller, ResourceFetch],\n\n  props: {\n    resource: {\n      type:     String,\n      required: true,\n    },\n    schema: {\n      type:     Object,\n      required: true,\n    },\n    useQueryParamsForSimpleFiltering: {\n      type:    Boolean,\n      default: false\n    },\n\n    listComponent: {\n      type:    Boolean,\n      default: false\n    }\n  },\n\n  async fetch() {\n    this.$initializeFetchData(this.resource);\n\n    await allHash({\n      kubeNodes: this.$fetchType(this.resource),\n      ...this.fetchSecondaryResources(),\n    });\n  },\n\n  data() {\n    return {\n      // Pods required for `Pods` column's running pods metrics\n      // podConsumedUsage = podConsumed / podConsumedUsage. podConsumed --> pods. allPods.filter((pod) => pod.spec.nodeName === this.name)\n      canViewPods:        !!this.$store.getters[`cluster/schemaFor`](POD),\n      // Norman node required for Drain/Cordon/Uncordon action\n      canViewNormanNodes: !!this.$store.getters[`rancher/schemaFor`](NORMAN.NODE),\n      // Mgmt Node required to find Norman node\n      canViewMgmtNodes:   !!this.$store.getters[`management/schemaFor`](MANAGEMENT.NODE),\n      // Required for ssh / download key actions\n      canViewMachines:    !!this.$store.getters[`management/schemaFor`](CAPI.MACHINE),\n      // Required for CPU and RAM columns\n      canViewNodeMetrics: !!this.$store.getters['cluster/schemaFor'](METRIC.NODE),\n    };\n  },\n\n  beforeDestroy() {\n    // Stop watching pods, nodes and node metrics\n    if (this.canViewPods) {\n      this.$store.dispatch('cluster/forgetType', POD);\n    }\n\n    this.$store.dispatch('cluster/forgetType', NODE);\n    this.$store.dispatch('cluster/forgetType', METRIC.NODE);\n  },\n\n  computed: {\n    ...mapGetters(['currentCluster']),\n    hasWindowsNodes() {\n      // Note if server side pagination is used this is only applicable to the current page\n      return (this.rows || []).some((node: any) => node.status.nodeInfo.operatingSystem === 'windows');\n    },\n\n    tableGroup: mapPref(GROUP_RESOURCES),\n\n    headers() {\n      // This is all about adding the pods column... if the user can see pods\n\n      if (this.canPaginate) {\n        const paginationHeaders = [...this.$store.getters['type-map/headersFor'](this.schema, true)];\n\n        if (paginationHeaders) {\n          if (this.canViewPods) {\n            paginationHeaders.splice(paginationHeaders.length - 1, 0, {\n              ...PODS,\n              breakpoint: COLUMN_BREAKPOINTS.DESKTOP,\n              sort:       false,\n              search:     false,\n              getValue:   (row: any) => row.podConsumedUsage\n            });\n          }\n\n          return paginationHeaders;\n        } else {\n          console.warn('Nodes list expects pagination headers but none found'); // eslint-disable-line no-console\n\n          return [];\n        }\n      }\n\n      const headers = [...this.$store.getters['type-map/headersFor'](this.schema, false)];\n\n      if (this.canViewPods) {\n        headers.splice(headers.length - 1, 0, {\n          ...PODS,\n          breakpoint: COLUMN_BREAKPOINTS.DESKTOP,\n          getValue:   (row: any) => row.podConsumedUsage\n        });\n      }\n\n      return headers;\n    },\n  },\n\n  methods: {\n    async loadMetrics() {\n      if (!this.canViewNodeMetrics) {\n        return;\n      }\n\n      if (this.canPaginate) {\n        if (!this.rows.length) {\n          return;\n        }\n\n        const opt: ActionFindPageArgs = {\n          force:      true,\n          pagination: new FilterArgs({\n            filters: new PaginationParamFilter({\n              fields: this.rows.map((r: any) => new PaginationFilterField({\n                field: 'metadata.name',\n                value: r.id\n              }))\n            })\n          })\n        };\n\n        await this.$store.dispatch('cluster/findPage', {\n          type: METRIC.NODE,\n          opt\n        });\n      } else {\n        await this.$store.dispatch('cluster/findAll', {\n          type: METRIC.NODE,\n          opt:  { force: true }\n        });\n      }\n\n      this.$forceUpdate();\n    },\n\n    toggleLabels(row: any) {\n      this.$set(row, 'displayLabels', !row.displayLabels);\n    },\n\n    fetchSecondaryResources(): { [key: string]: Promise<any>} {\n      if (this.canPaginate) {\n        return {};\n      }\n\n      const hash: { [key: string]: Promise<any>} = {};\n\n      if (this.canViewMgmtNodes) {\n        hash.mgmtNodes = this.$fetchType(MANAGEMENT.NODE, [], 'management');\n      }\n\n      if (this.canViewNormanNodes) {\n        hash.normanNodes = this.$fetchType(NORMAN.NODE, [], 'rancher');\n      }\n\n      if (this.canViewMachines) {\n        hash.machines = this.$fetchType(CAPI.MACHINE, [], 'management');\n      }\n\n      if (this.canViewPods) {\n        // No need to block on this\n        this.$fetchType(POD);\n      }\n\n      return hash;\n    },\n\n    /**\n     * Nodes columns need other resources in order to show data in some columns\n     *\n     * In the paginated world we want to resrict the fetch of those resources to only the one's we need\n     *\n     * So when we have a page.... use those entries as filters when fetching the other resources\n     */\n    async fetchPageSecondaryResources(force = false) {\n      if (!this.rows?.length) {\n        return;\n      }\n\n      if (this.canViewMgmtNodes && this.canViewNormanNodes) {\n        // We only fetch mgmt node to get norman node. We only fetch node to get node actions\n        // See https://github.com/rancher/dashboard/issues/10743\n        const opt: ActionFindPageArgs = {\n          force,\n          pagination: new FilterArgs({\n            filters: PaginationParamFilter.createMultipleFields(this.rows.map((r: any) => new PaginationFilterField({\n              field: 'status.nodeName',\n              value: r.id\n            }))),\n          })\n        };\n\n        this.$store.dispatch(`management/findPage`, { type: MANAGEMENT.NODE, opt })\n          .then(() => {\n            this.$store.dispatch(`rancher/findAll`, { type: NORMAN.NODE, opt: { force } });\n          });\n      }\n\n      if (this.canViewMachines) {\n        const namespace = this.currentCluster.provClusterId?.split('/')[0];\n\n        if (namespace) {\n          const opt: ActionFindPageArgs = {\n            force,\n            namespaced: namespace,\n            pagination: new FilterArgs({\n              filters: PaginationParamFilter.createMultipleFields(\n                this.rows.reduce((res: PaginationFilterField[], r: any ) => {\n                  const name = r.metadata?.annotations?.[CAPI_ANNOTATIONS.MACHINE_NAME];\n\n                  if (name) {\n                    res.push(new PaginationFilterField({\n                      field: 'metadata.name',\n                      value: name,\n                    }));\n                  }\n\n                  return res;\n                }, [])\n              )\n            })\n          };\n\n          this.$store.dispatch(`management/findPage`, { type: CAPI.MACHINE, opt });\n        }\n      }\n\n      if (this.canViewPods) {\n        // Note - fetching pods for current page could be a LOT still (probably max of 3k - 300 pods per node x 100 nodes in a page)\n        const opt: ActionFindPageArgs = {\n          force,\n          pagination: new FilterArgs({\n            filters: PaginationParamFilter.createMultipleFields(\n              this.rows.map((r: any) => new PaginationFilterField({\n                field: 'spec.nodeName',\n                value: r.id,\n              }))\n            )\n          })\n        };\n\n        this.$store.dispatch(`cluster/findPage`, { type: POD, opt });\n      }\n\n      // Fetch metrics given the current page\n      this.loadMetrics();\n    },\n  },\n});\n</script>\n\n<template>\n  <div>\n    <Banner\n      v-if=\"hasWindowsNodes\"\n      color=\"info\"\n      :label=\"t('cluster.custom.registrationCommand.windowsWarning')\"\n    />\n    <ResourceTable\n      v-bind=\"$attrs\"\n      :schema=\"schema\"\n      :headers=\"headers\"\n      :rows=\"rows\"\n      :sub-rows=\"true\"\n      :loading=\"loading\"\n      :use-query-params-for-simple-filtering=\"useQueryParamsForSimpleFiltering\"\n      :force-update-live-and-delayed=\"forceUpdateLiveAndDelayed\"\n      data-testid=\"cluster-node-list\"\n      :external-pagination-enabled=\"canPaginate\"\n      :external-pagination-result=\"paginationResult\"\n      @pagination-changed=\"paginationChanged\"\n      v-on=\"$listeners\"\n    >\n      <template #sub-row=\"{fullColspan, row, onRowMouseEnter, onRowMouseLeave}\">\n        <tr\n          class=\"taints sub-row\"\n          :class=\"{'empty-taints': ! row.displayTaintsAndLabels}\"\n          @mouseenter=\"onRowMouseEnter\"\n          @mouseleave=\"onRowMouseLeave\"\n        >\n          <template v-if=\"row.displayTaintsAndLabels\">\n            <td>&nbsp;</td>\n            <td>&nbsp;</td>\n            <td :colspan=\"fullColspan-2\">\n              <span v-if=\"row.spec.taints && row.spec.taints.length\">\n                {{ t('node.list.nodeTaint') }}:\n                <Tag\n                  v-for=\"taint in row.spec.taints\"\n                  :key=\"taint.key + taint.value + taint.effect\"\n                  class=\"mr-5 mt-2\"\n                >\n                  {{ taint.key }}={{ taint.value }}:{{ taint.effect }}\n                </Tag>\n              </span>\n              <span\n                v-if=\"!!row.customLabelCount\"\n                class=\"mt-5\"\n              > {{ t('node.list.nodeLabels') }}:\n                <span\n                  v-for=\"(label, i) in row.customLabels\"\n                  :key=\"i\"\n                  class=\"mt-5 labels\"\n                >\n                  <Tag\n                    v-if=\"i < 7\"\n                    class=\"mr-2 label\"\n                  >\n                    {{ label }}\n                  </Tag>\n                  <Tag\n                    v-else-if=\"i > 6 && row.displayLabels\"\n                    class=\"mr-2 label\"\n                  >\n                    {{ label }}\n                  </Tag>\n                </span>\n                <a\n                  v-if=\"row.customLabelCount > 7\"\n                  href=\"#\"\n                  @click.prevent=\"toggleLabels(row)\"\n                >\n                  {{ t(`node.list.${row.displayLabels? 'hideLabels' : 'showLabels'}`) }}\n                </a>\n              </span>\n            </td>\n          </template>\n          <td\n            v-else\n            :colspan=\"fullColspan\"\n          >\n&nbsp;\n          </td>\n        </tr>\n      </template>\n    </ResourceTable>\n  </div>\n</template>\n\n<style lang='scss' scoped>\n\n.labels {\n    display: inline;\n    flex-wrap: wrap;\n\n    .label {\n      display: inline-block;\n      margin-top: 2px;\n    }\n\n}\n.taints {\n  td {\n    padding-top:0;\n    .tag {\n      margin-right: 5px;\n      display: inline-block;\n      margin-top: 2px;\n    }\n  }\n  &.empty-taints {\n    // No taints... so hide sub-row (but not bottom-border)\n    height: 0;\n    line-height: 0;\n    td {\n      padding: 0;\n    }\n  }\n}\n\n</style>\n"]}]}